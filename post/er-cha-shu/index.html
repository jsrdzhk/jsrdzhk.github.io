<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>äºŒå‰æ ‘ | Rodney Cheung&#39;s HouseğŸ‡ºğŸ‡¦ğŸ—½</title>
<meta name="description" content="&lt;p&gt;I stand with UkraineğŸ‡ºğŸ‡¦!&lt;/p&gt;
&lt;p&gt;The king is noble only for practicing his way!&lt;/p&gt;
">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="https://jsrdzhk.github.io/favicon.ico?v=1678701535533">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://unpkg.com/papercss@1.6.1/dist/paper.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://jsrdzhk.github.io/styles/main.css">


<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


  </head>
  <body>
  
    <nav class="navbar border fixed split-nav">
  <div class="nav-brand">
    <h3><a href="https://jsrdzhk.github.io">Rodney Cheung&#39;s HouseğŸ‡ºğŸ‡¦ğŸ—½</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
      <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
        
          <li>
            
              <a href="/" class="menu">
                Home
              </a>
            
          </li>
        
          <li>
            
              <a href="/archives" class="menu">
                Archive
              </a>
            
          </li>
        
          <li>
            
              <a href="/tags" class="menu">
                Tag
              </a>
            
          </li>
        
          <li>
            
              <a href="https://jsrdzhk.github.io/post/readme" class="menu">
                README
              </a>
            
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div id="top" class="row site">
      <div class="sm-12 md-8 col">
        <div class="paper">
          <article class="article">
            <h1>äºŒå‰æ ‘</h1>
            <p class="article-meta">
              2021-07-10
              
                <a href="https://jsrdzhk.github.io/tag/_ydDLNY97/" class="badge secondary">
                  data structure
                </a>
              
                <a href="https://jsrdzhk.github.io/tag/s7a4AhfBW/" class="badge ">
                  tree
                </a>
              
            </p>
            
            <div class="post-content">
              <h2 id="ä¸€-å®šä¹‰">ä¸€ã€å®šä¹‰</h2>
<pre><code class="language-c++">struct TreeNode {
     int val;
     TreeNode *left;
     TreeNode *right;
     TreeNode() : val(0), left(nullptr), right(nullptr) {}
     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
</code></pre>
<h2 id="äºŒ-äºŒå‰æ ‘çš„éå†">äºŒã€äºŒå‰æ ‘çš„éå†</h2>
<h3 id="21-å‰åºéå†">2.1 å‰åºéå†</h3>
<p>å‰åºéå†ï¼ˆ<strong>Pre-Order Traversal</strong>ï¼‰çš„è®¿é—®é¡ºåºä¸ºï¼š</p>
<pre><code>æ ¹èŠ‚ç‚¹-&gt;å·¦å­æ ‘-&gt;å³å­æ ‘
</code></pre>
<h4 id="211-é€’å½’å†™æ³•">2.1.1 é€’å½’å†™æ³•</h4>
<pre><code class="language-c++">void recursivePreorderTraverseImpl(TreeNode *node, std::vector&lt;int&gt; &amp;res) {
    if (!node) {
        return;
    }
    res.push_back(node-&gt;val);
    recursivePreorderTraverseImpl(node-&gt;left, res);
    recursivePreorderTraverseImpl(node-&gt;right, res);
}

std::vector&lt;int&gt; recursivePreorderTraverse(TreeNode *root) {
    std::vector&lt;int&gt; res;
    recursivePreorderTraverseImpl(root, res);
    return res;
}
</code></pre>
<h4 id="212-è¿­ä»£å†™æ³•">2.1.2 è¿­ä»£å†™æ³•</h4>
<pre><code class="language-c++">std::vector&lt;int&gt; iterationPreorderTraverse(TreeNode *root) {
    std::vector&lt;int&gt; res;
    if (!root) {
        return res;
    }
    std::stack&lt;TreeNode *&gt; nodeStack;
    nodeStack.push(root);
    while (!nodeStack.empty()) {
        TreeNode *node = nodeStack.top();
        res.push_back(node-&gt;val);
        nodeStack.pop();
        if (node-&gt;right) {
            nodeStack.push(node-&gt;right);
        }
        if (node-&gt;left) {
            nodeStack.push(node-&gt;left);
        }
    }
    return res;
}
</code></pre>
<p>å½“ä½¿ç”¨è¿­ä»£éå†äºŒå‰æ ‘æ—¶ï¼Œä½¿ç”¨ä»¥ä¸‹æ­¥éª¤ï¼š</p>
<ol>
<li>é¦–å…ˆå°†æ ¹èŠ‚ç‚¹<code>push</code>æ ˆä¸­</li>
<li>è¯»å–æ ˆé¡¶çš„å€¼ï¼Œå¹¶å°†å³å­èŠ‚ç‚¹å’Œå·¦å­èŠ‚ç‚¹<code>push</code>åˆ°æ ˆä¸­ï¼Œå› ä¸ºæ ˆæ˜¯å…ˆå…¥åå‡ºï¼Œæ‰€ä»¥éœ€è¦æœ€åå°†å·¦å­èŠ‚ç‚¹<code>push</code>è¿›å»</li>
<li>é‡å¤1ã€2æ­¥è¯»å–æ ˆé¡¶èŠ‚ç‚¹</li>
</ol>
<h3 id="22-ä¸­åºéå†">2.2 ä¸­åºéå†</h3>
<p>ä¸­åºéå†ï¼ˆ<strong>In-Order Traversal</strong>ï¼‰çš„è®¿é—®é¡ºåºä¸ºï¼š</p>
<pre><code>å·¦å­æ ‘-&gt;æ ¹èŠ‚ç‚¹-&gt;å³å­æ ‘
</code></pre>
<h4 id="221-é€’å½’å†™æ³•">2.2.1 é€’å½’å†™æ³•</h4>
<pre><code class="language-c++">void recursiveInorderTraverseImpl(TreeNode *node, std::vector&lt;int&gt; &amp;res) {
    if (!node) {
        return;
    }
    recursiveInorderTraverseImpl(node-&gt;left, res);
    res.push_back(node-&gt;val);
    recursiveInorderTraverseImpl(node-&gt;right, res);
}

std::vector&lt;int&gt; recursiveInorderTraverse(TreeNode *root) {
    std::vector&lt;int&gt; res;
    recursiveInorderTraverseImpl(root, res);
    return res;
}
</code></pre>
<h4 id="222-è¿­ä»£å†™æ³•">2.2.2 è¿­ä»£å†™æ³•</h4>
<pre><code class="language-c++">std::vector&lt;int&gt; iterationInorderTraverse(TreeNode *root) {
    std::vector&lt;int&gt; res;
    std::stack&lt;TreeNode *&gt; nodeStack;
    while (root || !nodeStack.empty()) {
        while (root) {
            nodeStack.push(root);
            root = root-&gt;left;
        }
        root = nodeStack.top();
        nodeStack.pop();
        res.push_back(root-&gt;val);
        root = root-&gt;right;
    }
    return res;
}
</code></pre>
<p>è¿™é‡Œçš„æ€è·¯å°±æ˜¯æ¨¡æ‹Ÿé€’å½’çš„éå†è¿‡ç¨‹ï¼Œå…³é”®åœ¨äºä½¿ç”¨<code>std::stack</code>æ¥æ¨¡æ‹Ÿå‡½æ•°è°ƒç”¨æ ˆï¼š</p>
<ol>
<li>å°†æ ¹èŠ‚ç‚¹åŠå…¶å·¦å­èŠ‚ç‚¹éƒ½<code>push</code>åˆ°æ ˆä¸­</li>
<li>å½“å·¦å³æ ¹èŠ‚ç‚¹åŠå…¶å·¦å­èŠ‚ç‚¹éƒ½è¿›å…¥æ ˆä¸­åï¼Œå°†æ ˆé¡¶çš„èŠ‚ç‚¹å¼¹å‡ºï¼Œç”±äºè¯¥èŠ‚ç‚¹å·²ç»æ²¡æœ‰å·¦å­æ ‘ï¼Œæ‰€ä»¥é¦–å…ˆå°†å®ƒçš„å€¼æ”¾åˆ°ç»“æœé›†ä¸­ï¼Œç„¶åå°†æ ¹èŠ‚ç‚¹è®¾ä¸ºè¯¥èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹</li>
<li>é‡å¤1ã€2æ­¥ç›´è‡³æ ˆç©ºã€‚</li>
</ol>
<h3 id="23-ååºéå†">2.3 ååºéå†</h3>
<p>ä¸­åºéå†ï¼ˆ<strong>Post-Order Traversal</strong>ï¼‰çš„è®¿é—®é¡ºåºä¸ºï¼š</p>
<pre><code>å·¦å­æ ‘-&gt;å³å­æ ‘-&gt;æ ¹èŠ‚ç‚¹
</code></pre>
<h4 id="231-é€’å½’å†™æ³•">2.3.1 é€’å½’å†™æ³•</h4>
<pre><code class="language-c++">void recursivePostorderTraverseImpl(TreeNode *node, std::vector&lt;int&gt; &amp;res) {
    if (!node) {
        return;
    }
    recursivePostorderTraverseImpl(node-&gt;left, res);
    recursivePostorderTraverseImpl(node-&gt;right, res);
    res.push_back(node-&gt;val);
}

std::vector&lt;int&gt; recursivePostorderTraverse(TreeNode *root) {
    std::vector&lt;int&gt; res;
    recursivePostorderTraverseImpl(root, res);
    return res;
}
</code></pre>
<h4 id="232-è¿­ä»£å†™æ³•">2.3.2 è¿­ä»£å†™æ³•</h4>
<pre><code class="language-c++">std::vector&lt;int&gt; iterationPostorderTraverse(TreeNode *root) {
    std::vector&lt;int&gt; res;
    if (!root) {
        return res;
    }
    std::stack&lt;TreeNode *&gt; nodeStack;
    nodeStack.push(root);
    while (!nodeStack.empty()) {
        TreeNode *node = nodeStack.top();
        nodeStack.pop();
        res.push_back(node-&gt;val);
        if (node-&gt;left) {
            nodeStack.push(node-&gt;left);
        }
        if (node-&gt;right) {
            nodeStack.push(node-&gt;right);
        }
    }
    std::reverse(res.begin(), res.end());
    return res;
}
</code></pre>
<p>ç±»ä¼¼äºå‰åºéå†çš„è¿­ä»£å†™æ³•ï¼Œå½“æˆ‘ä»¬è°ƒæ¢pushåˆ°æ ˆä¸­çš„å·¦å³å­æ ‘é¡ºåºï¼Œé‚£ä¹ˆç»“æœå°±æ˜¯ï¼š</p>
<pre><code>[æ ¹èŠ‚ç‚¹] [å³å­æ ‘] [å·¦å­æ ‘]
</code></pre>
<p>å°†ç»“æœå€’åºï¼Œå°±æˆä¸ºäº†ï¼š</p>
<pre><code>[å·¦å­æ ‘] [å³å­æ ‘] [æ ¹èŠ‚ç‚¹]
</code></pre>
<h3 id="24-å±‚åºéå†">2.4 å±‚åºéå†</h3>
<p>å±‚åºéå†æŒ‰ç…§æ ‘çš„å±‚æ¬¡ä¾æ¬¡éå†æ ‘çš„èŠ‚ç‚¹ã€‚</p>
<h4 id="241-åˆ©ç”¨é˜Ÿåˆ—">2.4.1 åˆ©ç”¨é˜Ÿåˆ—</h4>
<pre><code class="language-c++">std::vector&lt;int&gt; levelorderTraverse(TreeNode *root) {
    std::vector&lt;int&gt; res;
    if (!root) {
        return res;
    }
    std::queue&lt;TreeNode *&gt; q;
    q.push(root);
    while (!q.empty()) {
        TreeNode *node = q.front();
        res.push_back(node-&gt;val);
        if (node-&gt;left) {
            q.push(node-&gt;left);
        }
        if (node-&gt;right) {
            q.push(node-&gt;right);
        }
        q.pop();
    }
    return res;
}
</code></pre>
<p>è¿™é‡Œå€ŸåŠ©é˜Ÿåˆ—å®Œæˆå±‚åºéå†ï¼š</p>
<ol>
<li>å°†æ ¹èŠ‚ç‚¹<code>push</code>åˆ°é˜Ÿåˆ—ä¸­</li>
<li>è¯»å–é˜Ÿåˆ—å¤´éƒ¨çš„èŠ‚ç‚¹å†…å®¹ï¼Œç„¶åå°†è¯¥èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹å’Œå³å­èŠ‚ç‚¹<code>push</code>åˆ°é˜Ÿåˆ—ä¸­</li>
<li>å°†é˜Ÿåˆ—å¤´éƒ¨èŠ‚ç‚¹å¼¹å‡ºé˜Ÿåˆ—</li>
<li>é‡å¤2ã€3æ­¥ç›´è‡³é˜Ÿåˆ—ä¸ºç©º</li>
</ol>
<h4 id="242-å°†ç»“æœæŒ‰å±‚è¾“å‡º">2.4.2 å°†ç»“æœæŒ‰å±‚è¾“å‡º</h4>
<p>ä¸Šä¸€èŠ‚å°†æ‰€æœ‰ç»“æœéƒ½æ”¾åˆ°ä¸€ä¸ªåŠ¨æ€æ•°ç»„ä¸­ï¼Œå¦‚æœéœ€è¦å°†ç»“æœåˆ†å±‚æ”¾å…¥åˆ°ä¸åŒçš„åŠ¨æ€æ•°ç»„ä¸­ï¼Œåˆ™éœ€è¦ç¨å¾®æ”¹åŠ¨ä¸€ç‚¹ä»£ç ã€‚å®é™…ä¸Šï¼Œåˆšåˆšæ¯æ¬¡è¯»å–å¤´éƒ¨èŠ‚ç‚¹å¹¶å°†å·¦å­èŠ‚ç‚¹å’Œå³å­èŠ‚ç‚¹<code>push</code>åˆ°é˜Ÿåˆ—ä¸­çš„æ“ä½œï¼Œå°±æ˜¯å°†ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹æ”¾åˆ°é˜Ÿåˆ—æœ«å°¾ï¼Œç­‰å¾…è¯¥å±‚æ‰€æœ‰èŠ‚ç‚¹éå†å®Œæ¯•ï¼Œæ‰å›å»éå†ä¸‹ä¸€å±‚çš„èŠ‚ç‚¹ã€‚</p>
<p>æ‰€ä»¥ï¼Œè¿™é‡Œä½¿ç”¨ä¸€ä¸ªè¾…åŠ©çš„é˜Ÿåˆ—ï¼Œç”¨äºå­˜æ”¾ä¸‹ä¸€å±‚çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚å½“è¯¥å±‚èŠ‚ç‚¹éƒ½éå†å®Œæˆåï¼Œåœ¨éå†è¾…åŠ©é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€å±‚èŠ‚ç‚¹ã€‚</p>
<pre><code class="language-c++">std::vector&lt;std::vector&lt;int&gt;&gt; levelorderTraverse2(TreeNode *root) {
    std::vector&lt;std::vector&lt;int&gt;&gt; res;
    if (!root) {
        return res;
    }
    std::queue&lt;TreeNode *&gt; q;
    q.push(root);
    while (!q.empty()) {
        std::queue&lt;TreeNode *&gt; tmp;
        std::vector&lt;int&gt; line;
        while (!q.empty()) {
            TreeNode *node = q.front();
            q.pop();
            line.push_back(node-&gt;val);
            if (node-&gt;left) {
                tmp.push(node-&gt;left);
            }
            if (node-&gt;right) {
                tmp.push(node-&gt;right);
            }
        }
        res.push_back(line);
        q = tmp;
    }
    return res;
}
</code></pre>
<p>å…¶å®ï¼Œä¸å€ŸåŠ©è¾…åŠ©é˜Ÿåˆ—ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œå› ä¸ºæ¯æ¬¡<code>push</code>éƒ½ä¼šå°†æ‰€æœ‰ä¸‹ä¸€å±‚çš„å­èŠ‚ç‚¹éƒ½æ”¾åˆ°é˜Ÿåˆ—ä¸­ï¼Œåªéœ€è¦åœ¨éå†è¿™äº›èŠ‚ç‚¹å‰è®°å½•ä¸‹ä¸€å±‚å­èŠ‚ç‚¹çš„æ•°é‡å³å¯ï¼š</p>
<pre><code class="language-c++">std::vector&lt;std::vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
    std::vector&lt;std::vector&lt;int&gt;&gt; res;
    std::queue&lt;TreeNode*&gt; q;
    q.push(root);
    while (!q.empty()) {
        auto len = q.size();
        std::vector&lt;int&gt; line;
        for (auto i = 0; i &lt; len; ++i) {
            TreeNode* n = q.front();
            q.pop();
            if (!n) {
                continue;
            }
            line.push_back(n-&gt;val);
            if (n-&gt;left) {
                q.push(n-&gt;left);
            }
            if (n-&gt;right) {
                q.push(n-&gt;right);
            }
        }
        if (!line.empty()) {
            res.push_back(line);
        }
    }
    return res;
}
</code></pre>
<h2 id="ä¸‰-nå‰æ ‘çš„éå†">ä¸‰ã€nå‰æ ‘çš„éå†</h2>
<p>nå‰æ ‘çš„å®šä¹‰ç±»ä¼¼äºäºŒå‰æ ‘ï¼Œnå‰æ ‘æ‹¥æœ‰ä¸å®šæ•°é‡çš„å­èŠ‚ç‚¹ï¼Œå®ƒçš„éå†ç›¸è¾ƒäºäºŒå‰æ ‘ï¼Œæ²¡æœ‰æœ¬è´¨åŒºåˆ«ï¼Œä¸‹é¢ä»…ç»™å‡ºä»£ç ã€‚</p>
<pre><code class="language-c++">class Node {
   public:
    int val;
    std::vector&lt;Node *&gt; children;
    Node() {}
    Node(int _val) { val = _val; }
    Node(int _val, std::vector&lt;Node *&gt; _children) {
        val = _val;
        children = _children;
    }
};
</code></pre>
<h3 id="31-å‰åºéå†">3.1 å‰åºéå†</h3>
<p><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589. N å‰æ ‘çš„å‰åºéå† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)</a></p>
<h4 id="311-é€’å½’å†™æ³•">3.1.1 é€’å½’å†™æ³•</h4>
<pre><code class="language-c++">void recursiveNArrPreorderTraverseImpl(Node *node, std::vector&lt;int&gt; &amp;res) {
    if (!node) {
        return;
    }
    res.push_back(node-&gt;val);
    for (auto c : node-&gt;children) {
        recursiveNArrPreorderTraverseImpl(c, res);
    }
}

std::vector&lt;int&gt; recursiveNArrPreorderTraverse(Node *root) {
    std::vector&lt;int&gt; res;
    recursiveNArrPreorderTraverseImpl(root, res);
    return res;
}
</code></pre>
<h4 id="312-è¿­ä»£å†™æ³•">3.1.2 è¿­ä»£å†™æ³•</h4>
<pre><code class="language-c++">std::vector&lt;int&gt; iterationNArrPreorderTraverse(Node *root) {
    std::vector&lt;int&gt; res;
    if (!root) {
        return res;
    }
    std::stack&lt;Node *&gt; s;
    s.push(root);
    while (!s.empty()) {
        Node *node = s.top();
        s.pop();
        res.push_back(node-&gt;val);
        auto &amp;c = node-&gt;children;
        for (auto rb = c.rbegin(); rb != c.rend(); ++rb) {
            if (*rb) {
                s.push(*rb);
            }
        }
    }
    return res;
}
</code></pre>
<h3 id="32-ååºéå†">3.2 ååºéå†</h3>
<p><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">590. N å‰æ ‘çš„ååºéå† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)</a></p>
<h4 id="321-é€’å½’å†™æ³•">3.2.1 é€’å½’å†™æ³•</h4>
<pre><code class="language-c++">void recursiveNArrPostorderTraverseImpl(Node *node, std::vector&lt;int&gt; &amp;res) {
    if (!node) {
        return;
    }
    for (auto c : node-&gt;children) {
        recursiveNArrPostorderTraverseImpl(c, res);
    }
    res.push_back(node-&gt;val);
}

std::vector&lt;int&gt; recursiveNArrPostorderTraverse(Node *root) {
    std::vector&lt;int&gt; res;
    recursiveNArrPostorderTraverseImpl(root, res);
    return res;
}
</code></pre>
<h4 id="322-è¿­ä»£å†™æ³•">3.2.2 è¿­ä»£å†™æ³•</h4>
<pre><code class="language-c++">std::vector&lt;int&gt; iterationNArrPostorderTraverse(Node *root) {
    std::vector&lt;int&gt; res;
    if (!root) {
        return res;
    }
    std::stack&lt;Node *&gt; s;
    s.push(root);
    while (!s.empty()) {
        Node *node = s.top();
        s.pop();
        res.push_back(node-&gt;val);
        auto &amp;c = node-&gt;children;
        for (auto pc : c) {
            s.push(pc);
        }
    }
    std::reverse(res.begin(), res.end());
    return res;
}
</code></pre>
<h3 id="33-å±‚åºéå†">3.3 å±‚åºéå†</h3>
<p><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">429. N å‰æ ‘çš„å±‚åºéå† - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)</a></p>
<pre><code class="language-c++">std::vector&lt;std::vector&lt;int&gt;&gt; nArrLevelorderTraverse(Node *root) {
    std::vector&lt;std::vector&lt;int&gt;&gt; res;
    if (!root) {
        return res;
    }
    std::queue&lt;Node *&gt; q;
    q.push(root);
    while (!q.empty()) {
        std::vector&lt;int&gt; line;
        std::queue&lt;Node *&gt; tmp;
        while (!q.empty()) {
            Node *n = q.front();
            q.pop();
            line.push_back(n-&gt;val);
            auto &amp;c = n-&gt;children;
            for (auto pc : c) {
                if (pc) {
                    tmp.push(pc);
                }
            }
        }
        res.push_back(line);
        q = tmp;
    }
    return res;
}
</code></pre>
<h2 id="å››-äºŒå‰æ ‘çš„åè½¬">å››ã€äºŒå‰æ ‘çš„åè½¬</h2>
<p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. ç¿»è½¬äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)</a></p>
<h3 id="41-é€’å½’å†™æ³•">4.1 é€’å½’å†™æ³•</h3>
<pre><code class="language-c++">void invertTreeImpl(TreeNode* node) {
    if (!node) {
        return;
    }
    std::swap(node-&gt;left, node-&gt;right);
    invertTreeImpl(node-&gt;left);
    invertTreeImpl(node-&gt;right);
}

TreeNode* invertTree(TreeNode* root) {
    if (!root) {
        return nullptr;
    }
    invertTreeImpl(root);
    return root;
}
</code></pre>
<h3 id="42-è¿­ä»£å†™æ³•">4.2 è¿­ä»£å†™æ³•</h3>
<pre><code class="language-c++">TreeNode* iterationInvertTree(TreeNode* root) {
    std::queue&lt;TreeNode*&gt; q;
    q.push(root);
    while (!q.empty()) {
        TreeNode* n = q.front();
        q.pop();
        if (!n) {
            continue;
        }
        std::swap(n-&gt;left, n-&gt;right);
        q.push(n-&gt;left);
        q.push(n-&gt;right);
    }
    return root;
}
</code></pre>
<h3 id="43-think">4.3 think</h3>
<p>åè½¬äºŒå‰æ ‘çš„ä¸»è¦æ­¥éª¤å°±æ˜¯<code>std::swap(n-&gt;left, n-&gt;right)</code>ï¼Œæ‰€ä»¥åªè¦å¯¹äºæ‰€æœ‰èŠ‚ç‚¹éƒ½æ‰§è¡Œä¸€æ¬¡<code>swap</code>æ“ä½œå°±å¯ä»¥äº†ï¼Œæ‰€ä»¥æœ¬è´¨ä¸Šï¼ŒäºŒå‰æ ‘çš„åè½¬ä¾æ—§æ˜¯äºŒå‰æ ‘çš„éå†é—®é¢˜ã€‚å¯¹äºé€’å½’å†™æ³•ï¼Œä½ å¯ä»¥å°†<code>swap</code>æ“ä½œæ”¾åœ¨é€’å½’è°ƒç”¨ç‚¹çš„ä»»ä½•åœ°æ–¹ï¼Œ<strong>ä½†æ˜¯æ³¨æ„ï¼Œå½“ä½ æ”¾åœ¨ä¸­é—´ä½¿ç”¨ä¸­åºéå†çš„æ—¶å€™ï¼Œéœ€è¦åšä¸€äº›å°çš„ä¿®æ”¹ï¼Œå› ä¸º<code>std::swap</code>ä¿®æ”¹äº†<code>TreeNode*</code>æŒ‡é’ˆçš„æŒ‡å‘ï¼Œæ‰€ä»¥ä½ éœ€è¦å°†ç¬¬äºŒä¸ª<code>node-&gt;right</code>ä¿®æ”¹ä¸º<code>node-&gt;left</code></strong>ï¼š</p>
<pre><code class="language-c++">void invertTreeInorderImpl(TreeNode* node) {
    if (!node) {
        return;
    }
    invertTreeInorderImpl(node-&gt;left);
    std::swap(node-&gt;left, node-&gt;right);
    invertTreeInorderImpl(node-&gt;left);
}
</code></pre>
<p>å¯¹äºè¿­ä»£å†™æ³•ï¼Œä¹Ÿæ˜¯åŒæ ·çš„é“ç†ã€‚</p>
<h2 id="äº”-å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ">äº”ã€å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ</h2>
<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)</a></p>
<h3 id="51-å±‚åºéå†">5.1 å±‚åºéå†</h3>
<p>ç”±äºäºŒå‰æ ‘ä¸ºå®Œç¾äºŒå‰æ ‘ï¼Œæ‰€æœ‰çˆ¶èŠ‚ç‚¹éƒ½æœ‰ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼Œæ‰€ä»¥é¦–å…ˆä¼šæƒ³åˆ°ä½¿ç”¨å±‚åºéå†ï¼Œå°†æ¯å±‚çš„èŠ‚ç‚¹éƒ½å­˜å‚¨åˆ°é˜Ÿåˆ—ä¸­ï¼Œç„¶åå¤„ç†é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹ï¼Œä»£ç åªéœ€è¦åœ¨[2.4.2](#2.4.2  å°†ç»“æœæŒ‰å±‚è¾“å‡º)çš„åŸºç¡€ä¸Šç¨ä½œä¿®æ”¹ï¼š</p>
<pre><code class="language-c++">Node* connect(Node* root) {
    std::queue&lt;Node*&gt; q;
    q.push(root);
    while (!q.empty()) {
        auto len = q.size();
        for (auto i = 0; i &lt; len; ++i) {
            Node* n = q.front();
            q.pop();
            if (!n) {
                continue;
            }
            if (i &lt; len - 1) {
                n-&gt;next = q.front();
            }
            q.push(n-&gt;left);
            q.push(n-&gt;right);
        }
    }
    return root;
}
</code></pre>
<h3 id="52-é€’å½’å†™æ³•">5.2 é€’å½’å†™æ³•</h3>
<p>æ ¹æ®è¦æ±‚ï¼Œéœ€è¦è®²æ‰€æœ‰å±‚çº§çš„å­èŠ‚ç‚¹éƒ½æŒ‡å‘å³ä¾§èŠ‚ç‚¹ï¼Œæ‰€ä»¥ä¸ä½†éœ€è¦å°†å·¦å³ä¸¤ä¸ªå­èŠ‚ç‚¹è¿æ¥ï¼Œè¿˜éœ€è¦å°†å‰ä¸€ä¸ªèŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹å’Œåä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹è¿æ¥ã€‚æ˜¾ç„¶ï¼Œä½¿ç”¨ä¸€ä¸ªèŠ‚ç‚¹æ— æ³•å®Œæˆè·¨èŠ‚ç‚¹çš„è¿æ¥ï¼Œæ‰€ä»¥éœ€è¦ä¸¤ä¸ªèŠ‚ç‚¹ï¼š</p>
<pre><code class="language-c++">void recursiveConnectImpl(Node* n1, Node* n2) {
    if (!n1 || !n2) {
        return;
    }
    n1-&gt;next = n2;
    recursiveConnectImpl(n1-&gt;left, n1-&gt;right);
    recursiveConnectImpl(n1-&gt;right, n2-&gt;left);
    recursiveConnectImpl(n2-&gt;left, n2-&gt;right);
}

Node* recursiveConnect(Node* root) {
    if (root) {
        recursiveConnectImpl(root-&gt;left, root-&gt;right);
    }
    return root;
}
</code></pre>
<h2 id="å…­-äºŒå‰æ ‘è½¬åŒ–ä¸ºé“¾è¡¨">å…­ã€äºŒå‰æ ‘è½¬åŒ–ä¸ºé“¾è¡¨</h2>
<p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)</a></p>
<h3 id="61-å‰åºéå†åä¿®æ”¹">6.1 å‰åºéå†åä¿®æ”¹</h3>
<p>å¾ˆè‡ªç„¶åœ°ï¼Œä½¿ç”¨å‰åºéå†çš„æ–¹å¼å°†æ‰€æœ‰èŠ‚ç‚¹éƒ½å­˜æ”¾åœ¨åŠ¨æ€æ•°ç»„ä¸­ï¼Œå†ä¾æ¬¡ä¿®æ”¹èŠ‚ç‚¹çš„æŒ‡å‘ï¼Œå½¢æˆå•å‘é“¾è¡¨ï¼š</p>
<pre><code class="language-c++">void traverseTree(TreeNode* node, std::vector&lt;TreeNode*&gt;&amp; res) {
    if (!node) {
        return;
    }
    res.push_back(node);
    traverseTree(node-&gt;left, res);
    traverseTree(node-&gt;right, res);
}

void flatten(TreeNode* root) {
    std::vector&lt;TreeNode*&gt; res;
    traverseTree(root, res);
    if (res.empty()) {
        return;
    }
    int len = res.size();
    for (auto i = 0; i &lt; len - 1; ++i) {
        res[i]-&gt;right = res[i + 1];
        res[i]-&gt;left = nullptr;
    }
}
</code></pre>
<p>è¿™é‡Œæ³¨æ„ï¼Œåœ¨<code>C++</code>ä¸­ï¼Œå½“<code>unsigned</code>ä¸<code>signed</code>ç›¸å‡æ—¶ï¼Œç»“æœä¼šè¢«è½¬åŒ–ä¸º<code>unsigned</code>ï¼Œæ‰€ä»¥å½“<code>root</code>èŠ‚ç‚¹ä¸º<code>nullptr</code>æ—¶ï¼Œå­˜æ”¾èŠ‚ç‚¹çš„<code>vector</code>å°±æ˜¯ç©ºçš„ï¼Œæ­¤æ—¶<code>res.size()-1</code>çš„ç»“æœä¼šç”±<code>-1</code>è½¬åŒ–ä¸º<code>unsigned</code>ï¼Œå…·ä½“ç»“æœæ ¹æ®æœºå™¨æ¶æ„çš„ä¸åŒè€Œæœ‰å·®å¼‚ã€‚åœ¨32ä½æœºå™¨ä¸Šï¼Œä¸€èˆ¬æ¥è¯´<code>signed</code>ä¼šä½¿ç”¨æœ€é«˜ä½è¡¨ç¤ºç¬¦å·ä½ï¼Œæ­¤æ—¶<code>-1</code>çš„äºŒè¿›åˆ¶è¡¨ç¤ºå°±æ˜¯<code>1000 0000 0000 0000 0000 0000 0000 0001</code>ï¼Œè½¬åŒ–ä¸º<code>unsigned</code>å°±æ˜¯<code>2^31+2^0</code>ï¼Œå³<code>2147483649</code>ï¼Œæ‰€ä»¥åœ¨<code>for</code>å¾ªç¯ä¸­æ¶‰åŠåˆ°<code>vector</code>çš„<code>size()</code>è¿ç®—æ—¶ï¼Œæœ€å¥½å…ˆè®²<code>size()</code>è½¬åŒ–ä¸º<code>signed</code>æ•´æ•°ã€‚</p>
<h3 id="62-é€’å½’å†™æ³•">6.2 é€’å½’å†™æ³•</h3>
<p>é€’å½’å†™æ³•åœ¨äºå…ˆå°†æ ‘å±•å¼€ï¼Œç„¶åå°†å·¦å­æ ‘æ¥åˆ°å³å­æ ‘ä¸Šï¼Œå†å°†åŸæ¥çš„å³å­æ ‘æ¥åˆ°å·¦å­æ ‘ä¸‹æ–¹:</p>
<pre><code class="language-c++">void flatten2(TreeNode* root) {
    if (!root) {
        return;
    }
    flatten2(root-&gt;left);
    flatten2(root-&gt;right);
    TreeNode* right = root-&gt;right;
    TreeNode* left = root-&gt;left;
    root-&gt;left = nullptr;
    root-&gt;right = left;
    TreeNode* p = root;
    while (p-&gt;right) {
        p = p-&gt;right;
    }
    p-&gt;right = right;
}
</code></pre>
<h2 id="ä¸ƒ-æ„å»ºäºŒå‰æ ‘">ä¸ƒã€æ„å»ºäºŒå‰æ ‘</h2>
<h3 id="71-æœ€å¤§äºŒå‰æ ‘">7.1 æœ€å¤§äºŒå‰æ ‘</h3>
<p><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. æœ€å¤§äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)</a></p>
<p>é¦–å…ˆè¦æ˜ç¡®æ¯æ¬¡é€’å½’è¦åšçš„äº‹æƒ…ï¼Œåœ¨è¿™é‡Œï¼Œæˆ‘ä»¬éœ€è¦ï¼š</p>
<ol>
<li>æ±‚å¾—æ•°ç»„çš„æœ€å¤§å€¼</li>
<li>å°†æœ€å¤§å€¼æ„å»ºä¸ºä¸€ä¸ªæ ‘èŠ‚ç‚¹å¹¶è¿æ¥åˆ°çˆ¶èŠ‚ç‚¹ä¸Š</li>
<li>åˆ†åˆ«å¯¹æœ€å¤§å€¼å·¦å³ä¸¤ä¾§çš„å­æ•°ç»„è¿›è¡Œé€’å½’è°ƒç”¨</li>
</ol>
<p><code>getMax</code>å‡½æ•°ç”¨äºæ±‚å¾—å­æ•°ç»„çš„æœ€å¤§å€¼åŠå…¶æ‰€å¤„çš„ä½ç½®ï¼Œè¿™é‡Œæˆ‘ä»¬é€‰å–çš„é€’å½’<code>base case</code>ä¸ºå½“æœ€å¤§å€¼çš„å·¦å³ä¸¤ä¾§æ˜¯å¦è¿˜å…·æœ‰å­æ•°ç»„ï¼š</p>
<pre><code class="language-c++">std::pair&lt;int, int&gt; getMax(const std::vector&lt;int&gt;&amp; nums, int s, int e) {
    int max = 0, maxPos = 0;
    for (auto i = s; i &lt;= e; ++i) {
        if (nums[i] &gt;= max) {
            max = nums[i];
            maxPos = i;
        }
    }
    return std::make_pair(max, maxPos);
}

TreeNode* constructImpl(const std::vector&lt;int&gt;&amp; nums, int s, int e) {
    auto maxPair = getMax(nums, s, e);
    auto maxNum = maxPair.first;
    auto maxPos = maxPair.second;
    TreeNode* newNode = new TreeNode(maxNum);
    if (maxPos &gt; s) {
        newNode-&gt;left = constructImpl(nums, s, maxPos - 1);
    }
    if (maxPos &lt; e) {
        newNode-&gt;right = constructImpl(nums, maxPos + 1, e);
    }
    return newNode;
}

TreeNode* constructMaximumBinaryTree(std::vector&lt;int&gt;&amp; nums) {
    if (nums.empty()) {
        return nullptr;
    }
    return constructImpl(nums, 0, nums.size() - 1);
}
</code></pre>
<h3 id="72-ä»å‰åºéå†å’Œä¸­åºéå†ç»“æœæ„å»ºäºŒå‰æ ‘">7.2 ä»å‰åºéå†å’Œä¸­åºéå†ç»“æœæ„å»ºäºŒå‰æ ‘</h3>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)</a></p>
<p>ç”±äºå‰åºéå†çš„ç»“æœä¸ºï¼š</p>
<pre><code>[æ ¹ç»“ç‚¹] [å·¦å­æ ‘] [å³å­æ ‘]
</code></pre>
<p>è€Œä¸­åºéå†çš„ç»“æœä¸ºï¼š</p>
<pre><code>[å·¦å­æ ‘] [æ ¹ç»“ç‚¹] [å³å­æ ‘]
</code></pre>
<p>åŒæ—¶åºåˆ—ä¸­æ²¡æœ‰é‡å¤æ•°å­—ï¼Œæ‰€ä»¥å¯ä»¥æ ¹æ®å‰åºéå†ç»“æœå¾—åˆ°æ ¹ç»“ç‚¹çš„å€¼ï¼Œå†åˆ°ä¸­åºéå†çš„ç»“æœä¸­æ‰¾åˆ°è¯¥å€¼æ‰€åœ¨çš„ä½ç½®ï¼Œå°±å¯ä»¥æ„å»ºè¯¥èŠ‚ç‚¹åŠå…¶å·¦å³å­æ ‘ï¼Œæ˜¾ç„¶è¿™æ˜¯ä¸€ä¸ªé€’å½’çš„æ„å»ºè¿‡ç¨‹ï¼š</p>
<pre><code class="language-c++">std::size_t getInorderRootPos(int rootNodeVal, const std::vector&lt;int&gt;&amp; inorder,
                              std::size_t inorderStart,
                              std::size_t inorderEnd) {
    for (auto i = inorderStart; i &lt;= inorderEnd; ++i) {
        if (inorder[i] == rootNodeVal) {
            return i;
        }
    }
    return 0;
}

TreeNode* constructBinaryTree(const std::vector&lt;int&gt;&amp; preorder,
                              const std::vector&lt;int&gt;&amp; inorder,
                              std::size_t preorderStart,
                              std::size_t preorderEnd, std::size_t inorderStart,
                              std::size_t inorderEnd) {
    auto rootNodeVal = preorder[preorderStart];
    TreeNode* n = new TreeNode(rootNodeVal);
    auto inorderRootPos =
        getInorderRootPos(rootNodeVal, inorder, inorderStart, inorderEnd);
    auto leftSubTreeLen = inorderRootPos - inorderStart;
    if (leftSubTreeLen &gt; 0) {
        n-&gt;left = constructBinaryTree(preorder, inorder, preorderStart + 1,
                                      preorderStart + leftSubTreeLen,
                                      inorderStart, inorderRootPos - 1);
    }
    auto rightSubTreeLen = inorderEnd - inorderRootPos;
    if (rightSubTreeLen &gt; 0) {
        n-&gt;right = constructBinaryTree(
            preorder, inorder, preorderStart + leftSubTreeLen + 1, preorderEnd,
            inorderRootPos + 1, inorderEnd);
    }
    return n;
}

TreeNode* buildTree(std::vector&lt;int&gt;&amp; preorder, std::vector&lt;int&gt;&amp; inorder) {
    if (preorder.empty()) {
        return nullptr;
    }
    return constructBinaryTree(preorder, inorder, 0, preorder.size() - 1, 0,
                               inorder.size() - 1);
}
</code></pre>
<h3 id="73-ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘">7.3 ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘</h3>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)</a></p>
<p>ç”±äºååºéå†çš„ç»“æœä¸ºï¼š</p>
<pre><code>[å·¦å­æ ‘] [å³å­æ ‘] [æ ¹ç»“ç‚¹]
</code></pre>
<p>æ‰€ä»¥å¯ä»¥æ‰¾åˆ°è·ŸèŠ‚ç‚¹çš„å€¼ã€‚</p>
<p>åˆå› ä¸ºåºåˆ—æ²¡æœ‰é‡å¤æ•°å­—ï¼Œè€Œä¸­åºéå†çš„ç»“æœä¸ºï¼š</p>
<pre><code>[å·¦å­æ ‘] [æ ¹ç»“ç‚¹] [å³å­æ ‘]
</code></pre>
<p>æ‰€ä»¥å¯ä»¥å¾—åˆ°æ”¹æ ¹ç»“ç‚¹çš„å·¦å³å­æ ‘ï¼Œä»£ç ç±»ä¼¼<code>7.2</code>ï¼š</p>
<pre><code class="language-c++">std::size_t getInorderRootPos(int rootNodeVal, const std::vector&lt;int&gt;&amp; inorder,
                              std::size_t inorderStart,
                              std::size_t inorderEnd) {
    for (auto i = inorderStart; i &lt;= inorderEnd; ++i) {
        if (inorder[i] == rootNodeVal) {
            return i;
        }
    }
    return 0;
}

TreeNode* constructBinaryTree(const std::vector&lt;int&gt;&amp; postorer,
                              const std::vector&lt;int&gt;&amp; inorder,
                              std::size_t postorerStart,
                              std::size_t postorerEnd, std::size_t inorderStart,
                              std::size_t inorderEnd) {
    auto rootNodeVal = postorer[postorerEnd];
    TreeNode* n = new TreeNode(rootNodeVal);
    auto inorderRootPos =
        getInorderRootPos(rootNodeVal, inorder, inorderStart, inorderEnd);
    auto leftSubTreeLen = inorderRootPos - inorderStart;
    if (leftSubTreeLen &gt; 0) {
        n-&gt;left = constructBinaryTree(postorer, inorder, postorerStart,
                                      postorerStart + leftSubTreeLen - 1,
                                      inorderStart, inorderRootPos - 1);
    }
    auto rightSubTreeLen = inorderEnd - inorderRootPos;
    if (rightSubTreeLen &gt; 0) {
        n-&gt;right = constructBinaryTree(
            postorer, inorder, postorerStart + leftSubTreeLen, postorerEnd - 1,
            inorderRootPos + 1, inorderEnd);
    }
    return n;
}

TreeNode* buildTree(std::vector&lt;int&gt;&amp; inorder, std::vector&lt;int&gt;&amp; postorder) {
    if (postorder.empty()) {
        return nullptr;
    }
    return constructBinaryTree(postorder, inorder, 0, postorder.size() - 1, 0,
                               inorder.size() - 1);
}
</code></pre>
<h2 id="å…«-å¯»æ‰¾é‡å¤å­æ ‘">å…«ã€å¯»æ‰¾é‡å¤å­æ ‘</h2>
<p><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">652. å¯»æ‰¾é‡å¤çš„å­æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)</a></p>
<p>ä½¿ç”¨å‰åºéå†ï¼Œå°†æ‰€æœ‰å­æ ‘çš„å‰åºéå†ç»“æœä¿å­˜åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œå½“å‰åºéå†ç»“æœç­‰äº2æ—¶ï¼Œè¯´æ˜æ­¤å­æ ‘é‡å¤ã€‚</p>
<pre><code class="language-c++">std::string getSubTreeSeq(TreeNode* n,
                          std::unordered_map&lt;std::string, int&gt;&amp; counter,
                          std::vector&lt;TreeNode*&gt;&amp; res) {
    if (!n) {
        return &quot;$&quot;;
    }
    std::ostringstream oss;
    oss &lt;&lt; n-&gt;val &lt;&lt; ',' &lt;&lt; getSubTreeSeq(n-&gt;left, counter, res) &lt;&lt; ','
        &lt;&lt; getSubTreeSeq(n-&gt;right, counter, res);
    std::string seq = oss.str();
    ++counter[seq];
    if (counter[seq] == 2) {
        res.push_back(n);
    }
    return seq;
}

std::vector&lt;TreeNode*&gt; findDuplicateSubtrees2(TreeNode* root) {
    std::unordered_map&lt;std::string, int&gt; counter;
    std::vector&lt;TreeNode*&gt; res;
    getSubTreeSeq(root, counter, res);
    return res;
}
</code></pre>

            </div>
          </article>
        </div>
        <div class="paper" data-aos="fade-in">
          
            <div class="next-post">
              <div class="next">
                Next Blog
              </div>
              <a href="https://jsrdzhk.github.io/post/zhong-duan-dai-li-jiao-ben/">
                <h3 class="post-title">
                  terminalå¦‚ä½•èµ°ä»£ç†
                </h3>
              </a>
            </div>
          
        </div>
        
      </div>

      <div class="sm-12 md-4 col sidebar">
  <div class="paper info-container">
    <img src="https://jsrdzhk.github.io/images/avatar.png?v=1678701535533" class="no-responsive avatar">
    <div class="text-muted"><p>I stand with UkraineğŸ‡ºğŸ‡¦!</p>
<p>The king is noble only for practicing his way!</p>
</div>
    <div class="social-container">
      
        
          <a href="https://github.com/jsrdzhk" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
          <a href="https://twitter.com/jsrdzhk" target="_blank">
            <i class="fab fa-twitter"></i>
          </a>
        
      
        
      
        
      
        
      
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      Latest Blog
    </div>
    <div class="row">
      <ul>
        
          
            <li>
              <a href="https://jsrdzhk.github.io/post/er-fen-cha-zhao/">äºŒåˆ†æŸ¥æ‰¾</a>
            </li>
          
        
          
            <li>
              <a href="https://jsrdzhk.github.io/post/li-jie-czhong-de-zuo-zhi-he-you-zhi/">ç†è§£C++ä¸­çš„å·¦å€¼å’Œå³å€¼</a>
            </li>
          
        
          
            <li>
              <a href="https://jsrdzhk.github.io/post/jian-dan-de-shared_ptr-shi-xian/">ç®€å•çš„shared_ptrå®ç°</a>
            </li>
          
        
          
            <li>
              <a href="https://jsrdzhk.github.io/post/lian-biao-xiang-guan/">é“¾è¡¨ç›¸å…³</a>
            </li>
          
        
          
            <li>
              <a href="https://jsrdzhk.github.io/post/tu-xiang-guan/">å›¾ç›¸å…³</a>
            </li>
          
        
          
            <li>
              <a href="https://jsrdzhk.github.io/post/er-cha-sou-suo-shu-bst/">äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰</a>
            </li>
          
        
          
            <li>
              <a href="https://jsrdzhk.github.io/post/git-ji-chu-yi/">GitåŸºç¡€(ä¸€)</a>
            </li>
          
        
          
            <li>
              <a href="https://jsrdzhk.github.io/post/docker-image-import-and-export/">Dockeré•œåƒå¯¼å…¥å¯¼å‡º</a>
            </li>
          
        
          
            <li>
              <a href="https://jsrdzhk.github.io/post/docker-installation/">Dockerå®‰è£…</a>
            </li>
          
        
          
            <li>
              <a href="https://jsrdzhk.github.io/post/er-cha-shu/">äºŒå‰æ ‘</a>
            </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      Tag List
    </div>
    <div class="row">
      
        <a href="https://jsrdzhk.github.io/tag/weUBFlLDD/" class="badge secondary">
          binary search
        </a>
      
        <a href="https://jsrdzhk.github.io/tag/MGd4HYSuo/" class="badge secondary">
          cpp
        </a>
      
        <a href="https://jsrdzhk.github.io/tag/KKjUQ4MWe/" class="badge ">
          Smart Pointers
        </a>
      
        <a href="https://jsrdzhk.github.io/tag/ej_j7SeTH/" class="badge ">
          LinkedList
        </a>
      
        <a href="https://jsrdzhk.github.io/tag/_ydDLNY97/" class="badge secondary">
          data structure
        </a>
      
        <a href="https://jsrdzhk.github.io/tag/84fw4eg0Y/" class="badge ">
          Graph
        </a>
      
        <a href="https://jsrdzhk.github.io/tag/0q-BX870D/" class="badge warning">
          BST
        </a>
      
        <a href="https://jsrdzhk.github.io/tag/s7a4AhfBW/" class="badge success">
          tree
        </a>
      
        <a href="https://jsrdzhk.github.io/tag/J6bMD7YjK/" class="badge success">
          Git
        </a>
      
        <a href="https://jsrdzhk.github.io/tag/-i04JmKge/" class="badge success">
          docker
        </a>
      
        <a href="https://jsrdzhk.github.io/tag/pX3bayx0K/" class="badge warning">
          proxy
        </a>
      
        <a href="https://jsrdzhk.github.io/tag/JtKSwj9dO/" class="badge secondary">
          Android
        </a>
      
        <a href="https://jsrdzhk.github.io/tag/ZheDh5Fg9/" class="badge warning">
          Kotlin
        </a>
      
        <a href="https://jsrdzhk.github.io/tag/7Fzphc59o/" class="badge warning">
          Python
        </a>
      
    </div>
  </div>
  <div class="paper">
    Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://jsrdzhk.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>


    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

</script>




  </body>
</html>
