<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jsrdzhk.github.io</id>
    <title>Rodney Cheung&apos;s House🇺🇦🗽</title>
    <updated>2023-03-13T09:59:09.987Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jsrdzhk.github.io"/>
    <link rel="self" href="https://jsrdzhk.github.io/atom.xml"/>
    <subtitle>&lt;p&gt;I stand with Ukraine🇺🇦!&lt;/p&gt;
&lt;p&gt;The king is noble only for practicing his way!&lt;/p&gt;
</subtitle>
    <logo>https://jsrdzhk.github.io/images/avatar.png</logo>
    <icon>https://jsrdzhk.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Rodney Cheung&apos;s House🇺🇦🗽</rights>
    <entry>
        <title type="html"><![CDATA[二分查找]]></title>
        <id>https://jsrdzhk.github.io/post/er-fen-cha-zhao/</id>
        <link href="https://jsrdzhk.github.io/post/er-fen-cha-zhao/">
        </link>
        <updated>2021-07-20T08:15:22.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-查找升序数组中是否存在某个数">一、查找升序数组中是否存在某个数</h2>
<p><a href="https://leetcode-cn.com/problems/binary-search/submissions/">704. 二分查找 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>代码非常简单，但要注意以下几点：</p>
<ol>
<li>求中点的时候应使用<code>start + (end - start) / 2</code>，这样可以避免结果溢出</li>
<li>初始化<code>start</code>和<code>end</code>的值时，既可以选择左开右闭区间，即<code>[start,end)</code>，也可以使用全闭区间。一般来说左开右闭区间的写法较为常用，因为他相较于全闭区间可以省略几个符号。</li>
</ol>
<pre><code class="language-c++">int search(std::vector&lt;int&gt;&amp; nums, int target) {
    int start = 0, end = nums.size();
    while (start &lt; end) {
        int middle = start + (end - start) / 2;
        if (nums[middle] &gt; target) {
            end = middle;
        } else if (nums[middle] == target) {
            return middle;
        } else {
            start = middle + 1;
        }
    }
    return -1;
}
</code></pre>
<h2 id="二-查找升序数组中某个数的范围">二、查找升序数组中某个数的范围</h2>
<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>只需要在上述代码中稍作修改既可以：</p>
<pre><code class="language-c++">std::vector&lt;int&gt; searchRange(std::vector&lt;int&gt;&amp; nums, int target) {
    int left = 0, right = nums.size();
    std::vector&lt;int&gt; res{-1, -1};
    if (nums.empty()) {
        return res;
    }
    while (left &lt; right) {
        int middle = left + (right - left) / 2;
        //当middle位置的数大于目标数时，说明目标数在该数的左侧;
        //当等于目标数时，说明该数的左侧（不包括该数）也可能存在跟目标数相同的其他数，继续向左二分查找
        if (nums[middle] &gt;= target) {
            right = middle;
        } else {
            left = middle + 1;
        }
    }
    //当下标处数据非法时，说明没有找到目标数，直接返回
    if (left &gt;= nums.size()) {
        return res;
    }
    if (nums[left] == target) {
        res[0] = left;
    } else {
        return res;
    }
    right = nums.size();
    while (left &lt; right) {
        int middle = left + (right - left) / 2;
        if (nums[middle] &gt; target) {
            right = middle;
        } else {
            //当middle位置的数等于目标数时，说明该数右侧的数字也有可能等于目标数，继续向右二分查找。
            left = middle + 1;
        }
    }
    //此时右侧的数必然在目标数右边，所以目标数的右侧下标需要减一
    res[1] = left - 1;
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[理解C++中的左值和右值]]></title>
        <id>https://jsrdzhk.github.io/post/li-jie-czhong-de-zuo-zhi-he-you-zhi/</id>
        <link href="https://jsrdzhk.github.io/post/li-jie-czhong-de-zuo-zhi-he-you-zhi/">
        </link>
        <updated>2021-07-15T09:29:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-前言">一、前言</h2>
<p>一直以来，我都对C++中左值（lvalue）和右值（lvalue）的概念模糊不清。我认为是时候好好理解他们了，因为这些概念随着C++语言的进化变得越来越重要。</p>
<h2 id="二-左值和右值一个友好的定义">二、左值和右值——一个友好的定义</h2>
<p>首先，让我们避开那些正式的定义。在C++中，一个左值是指向一个指定内存的东西。另一方面，右值就是不指向任何地方的东西。通常来说，右值是暂时和短命的，而左值则活的很久，因为他们以变量的形式（variable）存在。我们可以将左值看作为容器（container）而将右值看做容器中的事物。如果容器消失了，容器中的事物也就自然就无法存在了。<br>
让我们现在来看一些例子：</p>
<pre><code class="language-cpp">int x = 666; //ok
</code></pre>
<p>在这里，<code>666</code>是一个右值。一个数字（从技术角度来说他是一个字面常量（literal constant））没有指定的内存地址，当然在程序运行时一些临时的寄存器除外。在该例中，<code>666</code>被赋值（assign）给<code>x</code>，<code>x</code>是一个变量。一个变量有着具体（specific）的内存位置，所以他是一个左值。C++中声明一个赋值（assignment）需要一个左值作为它的左操作数（left operand）：这完全合法。<br>
对于左值<code>x</code>，你可以做像这样的操作：</p>
<pre><code class="language-cpp">int* y = &amp;x;  //ok
</code></pre>
<p>在这里我通过取地址操作符<code>&amp;</code>获取了<code>x</code>的内存地址并且把它放进了<code>y</code>。<code>&amp;</code>操作符需要一个左值并且产生了一个右值，这也是另一个完全合法的操作：在赋值操作符的左边我们有一个左值（一个变量），在右边我们使用取地址操作符产生的右值。<br>
然而，我们不能这样写：</p>
<pre><code class="language-cpp">int y;
666 = y; //error!
</code></pre>
<p>可能上面的结论是显而易见的，但是从技术上来说是因为<code>666</code>是一个字面常量也就是一个右值，它没有一个具体的内存位置（memory location），所以我们会把<code>y</code>分配到一个不存在的地方。<br>
下面是GCC给出的变异错误提示：</p>
<blockquote>
<p>error: lvalue required as left operand of assignment</p>
</blockquote>
<p>赋值的左操作数需要一个左值，这里我们使用了一个右值<code>666</code>。<br>
我们也不能这样做：</p>
<pre><code class="language-cpp">int* y = &amp;666;//   error~
</code></pre>
<p>GCC给出了以下错误提示：</p>
<blockquote>
<p>error: lvalue required as unary '&amp;' operand`</p>
</blockquote>
<p><code>&amp;</code>操作符需要一个左值作为操作数，因为只有一个左值才拥有地址。</p>
<h2 id="三-返回左值和右值的函数">三、返回左值和右值的函数</h2>
<p>我们知道一个赋值的左操作数必须是一个左值，因此下面的这个函数肯定会抛出错误：<code>lvalue required as left operand of assignment</code></p>
<pre><code class="language-cpp">int setValue()
{
    return 6;
}

// ... somewhere in main() ...

setValue() = 3; // error!
</code></pre>
<p>错误原因很清楚：<code>setValue()</code>返回了一个右值（一个临时值<code>6</code>），他不能作为一个赋值的左操作数。现在，我们看看如果函数返回一个左值，这样的赋值会发生什么变化。看下面的代码片段（snippet）：</p>
<pre><code class="language-cpp">int global = 100;

int&amp; setGlobal()
{
    return global;    
}

// ... somewhere in main() ...

setGlobal() = 400; // OK
</code></pre>
<p>该程序可以运行，因为在这里<code>setGlobal()</code>返回一个引用（reference），跟之前的<code>setValue()</code>不同。一个引用是指向一个已经存在的内存位置（<code>global</code>变量）的东西，因此它是一个左值，所以它能被赋值。注意这里的<code>&amp;</code>：它不是取地址操作符，他定义了返回的类型（一个引用）。<br>
可以从函数返回左值看上去有些隐晦，它在你做一些进阶的编程例如实现一些操作符的重载（implementing overload operators）时会很有作用，这些知识会在未来的章节中讲述。</p>
<h2 id="四-左值到右值的转换">四、左值到右值的转换</h2>
<p>一个左值可以被转换（convert）为右值，这完全合法且经常发生。让我们先用<code>+</code>操作符作为一个例子，根据C++的规范（specification），它使用两个右值作为参数并返回一个右值（译者按：可以将操作符理解为一个函数）。<br>
让我们看下面的代码片段：</p>
<pre><code class="language-cpp">int x = 1;
int y = 3;
int z = x + y;   // ok
</code></pre>
<p>等一下，<code>x</code>和<code>y</code>是左值，但是加法操作符需要右值作为参数：发生了什么？答案很简单：<code>x</code>和<code>y</code>经历了一个隐式（implicit）的左值到右值（lvalue-to-rvalue）的转换。许多其他的操作符也有同样的转换——减法、加法、除法等等。</p>
<h2 id="五-左值引用">五、左值引用</h2>
<p>相反呢？一个右值可以被转化为左值吗？不可以，它不是技术所限，而是C++编程语言就是那样设计的。<br>
在C++中，当你做这样的事：</p>
<pre><code class="language-cpp">int y = 10;
int&amp; yref = y;
yref++;        // y is now 11
</code></pre>
<p>这里将<code>yref</code>声明为类型<code>int&amp;</code>：一个对<code>y</code>的引用，它被称作左值引用（lvalue reference）。现在你可以开心地通过该引用改变<code>y</code>的值了。<br>
我们知道，一个引用必须只想一个具体的内存位置中的一个已经存在的对象，即一个左值。这里<code>y</code>确实存在，所以代码运行完美。<br>
现在，如果我缩短整个过程，尝试将<code>10</code>直接赋值给我的引用，并且没有任何对象持有该引用，将会发生什么？</p>
<pre><code class="language-cpp">int&amp; yref = 10;  // will it work?
</code></pre>
<p>在右边我们有一个临时值，一个需要被存储在一个左值中的右值。在左边我们有一个引用（一个左值），他应该指向一个已经存在的对象。但是<code>10</code> 是一个数字常量（numeric constant），也就是一个左值，将它赋给引用与引用所表述的精神冲突。<br>
如果你仔细想想，那就是被禁止的从右值到左值的转换。一个<code>volitile</code>的数字常量（右值）如果想要被引用，需要先变成一个左值。如果那被允许，你就可以通过它的引用来改变数字常量的值。相当没有意义，不是吗？更重要的是，一旦这些值不再存在这些引用该指向哪里呢？<br>
下面的代码片段同样会发生错误，原因跟刚才的一样：</p>
<pre><code class="language-cpp">void fnc(int&amp; x)
{
}

int main()
{
    fnc(10);  // Nope!
    // This works instead:
    // int x = 10;
    // fnc(x);
}
</code></pre>
<p>我将一个临时值<code>10</code>传入了一个需要引用作为参数的函数中，产生了将右值转换为左值的错误。这里有一个解决方法（workaround），创造一个临时的变量来存储右值，然后将变量传入函数中（就像注释中写的那样）。将一个数字传入一个函数确实不太方便。</p>
<h2 id="六-常量左值引用">六、常量左值引用</h2>
<p>先看看GCC对于之前两个代码片段给出的错误提示：</p>
<blockquote>
<p>error: invalid initialization of non-const reference of type 'int&amp;' from an rvalue of type 'int'</p>
</blockquote>
<p>GCC认为引用不是<code>const</code>的，即一个常量。根据C++规范，你可以将一个<code>const</code>的左值绑定到一个右值上，所以下面的代码可以成功运行：</p>
<pre><code class="language-cpp">const int&amp; ref = 10;  // OK!
</code></pre>
<p>当然，下面的也是：</p>
<pre><code class="language-cpp">void fnc(const int&amp; x)
{
}

int main()
{
    fnc(10);  // OK!
}
</code></pre>
<p>背后的道理是相当直接的，字面常量<code>10</code>是<code>volatile</code>的并且会很快失效（expire），所以给他一个引用是没什么意义的。如果我们让引用本身变成常量引用，那样的话该引用指向的值就不能被改变了。现在右值被修改的问题被很好地解决了。同样，这不是一个技术限制，而是C ++人员为避免愚蠢麻烦所作的选择。<br>
<em>应用：C++中经常通过常量引用来将值传入函数中，这避免了不必要的临时对象的创建和拷贝。</em><br>
编译器会为你创建一个隐藏的变量（即一个左值）来存储初始的字面常量，然后将隐藏的变量绑定到你的引用上去。那跟我之前的一组代码片段中手动完成的是一码事，例如：</p>
<pre><code class="language-cpp">// the following...
const int&amp; ref = 10;

// ... would translate to:
int __internal_unique_name = 10;
const int&amp; ref = __internal_unique_name;
</code></pre>
<p>现在你的引用指向了真实存在的事物（知道它走出作用域外）并且你可以正常使用它，出克改变他指向的值。</p>
<pre><code class="language-cpp">const int&amp; ref = 10;
std::cout &lt;&lt; ref &lt;&lt; &quot;\n&quot;;   // OK!
std::cout &lt;&lt; ++ref &lt;&lt; &quot;\n&quot;; // error: increment of read-only reference ‘ref’
</code></pre>
<h2 id="七-结论">七、结论</h2>
<p>理解左值和右值的含义让我弄清楚了几个C++内在的工作方式。C++11进一步推动了右值的限定，引入了右值引用（rvalue reference）和移动（move semantics）的概念。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[简单的shared_ptr实现]]></title>
        <id>https://jsrdzhk.github.io/post/jian-dan-de-shared_ptr-shi-xian/</id>
        <link href="https://jsrdzhk.github.io/post/jian-dan-de-shared_ptr-shi-xian/">
        </link>
        <updated>2021-07-15T09:27:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-前言">一、前言</h2>
<p><code>C++11</code>为我们带来了<code>std::shared_ptr</code>，方便我们在动态分配内存的时候发生memory leak，他是基于引用计数实现的，下面给出一个简化版本。</p>
<h2 id="二-实现">二、实现</h2>
<pre><code class="language-c++">namespace smart_ptr {
class counter {
   public:
    counter(unsigned cnt) : count_(cnt) {}

    unsigned&amp; operator++() {
        ++count_;
        return count_;
    }

    unsigned operator++(int) {
        unsigned count = count_;
        ++count_;
        return count;
    }

    unsigned&amp; operator--() {
        --count_;
        return count_;
    }

    unsigned operator--(int) {
        unsigned count = count_;
        --count_;
        return count;
    }
    unsigned getCount() const { return count_; }

   private:
    unsigned count_ = 0;
};

template &lt;typename T&gt;
class shared_ptr {
   public:
    using pointer = T*;
    using reference = T&amp;;
    shared_ptr(pointer ptr) {
        counter_ = new counter(1);
        data_ = ptr;
    }
    ~shared_ptr() {
        --(*counter_);
        if (counter_-&gt;getCount() == 0) {
            delete data_;
            data_ = nullptr;
            delete counter_;
            counter_ = nullptr;
        }
    }

    shared_ptr(const shared_ptr&lt;T&gt;&amp; s_ptr) {
        counter_ = s_ptr.counter_;
        ++(*counter_);
        data_ = s_ptr.data_;
    }

    pointer get() const { return data_; }

    unsigned use_count() const { return counter_-&gt;count_; }
    pointer operator-&gt;() { return data_; }

    reference operator*() { return *data_; }

   private:
    counter* counter_;
    pointer data_;
};
}  // namespace smart_ptr
</code></pre>
<p>在这里我们声明了一个类<code>counter</code>专门用于计算指向动态内存的对象数量，在我们创建<code>shared_ptr</code>对象时，动态分配一个内存给成员<code>counter_</code>，当对象发生拷贝时，使用同一个<code>counter</code>增加引用计数。在析构时，我们将<code>counter</code>进行自减，如果自减后<code>counter</code>为零，那么就释放动态分配的内存。也就是说，如果我们想要像<code>new</code>操作符一样手动析构，那么我们只需要手动调用<code>~shared_ptr()</code>即可。<strong>手动调用析构函数只是销毁了对象，并没有释放这段内存。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链表相关]]></title>
        <id>https://jsrdzhk.github.io/post/lian-biao-xiang-guan/</id>
        <link href="https://jsrdzhk.github.io/post/lian-biao-xiang-guan/">
        </link>
        <updated>2021-07-14T02:49:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-定义">一、定义</h2>
<p>单向链表：</p>
<pre><code class="language-c++">struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
</code></pre>
<h2 id="二-反转链表">二、反转链表</h2>
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h3 id="21-迭代写法">2.1 迭代写法</h3>
<pre><code class="language-c++">ListNode* iterationReverseList(ListNode* head) {
    if (!head || !head-&gt;next) {
        return head;
    }
    ListNode* prev = nullptr;
    while (head) {
        ListNode* next = head-&gt;next;
        head-&gt;next = prev;
        prev = head;
        head = next;
    }
    return head;
}
</code></pre>
<h3 id="22-递归写法">2.2 递归写法</h3>
<pre><code class="language-c++">ListNode* recursiveReverseList(ListNode* head) {
    if (!head || !head-&gt;next) {
        return head;
    }
    ListNode* last = recursiveReverseList(head-&gt;next);
    head-&gt;next-&gt;next = head;
    head-&gt;next = nullptr;
    return last;
}
</code></pre>
<h2 id="三-判断链表是否是回文">三、判断链表是否是回文</h2>
<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/submissions/">234. 回文链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>如果不要求空间复杂度，可以直接将链表所有值都读取到数组中，并使用双指针判断是否是回文。如果要求空间复杂度为<code>O(1)</code>，那么则需要利用快慢指针找到链表的中点，并反转剩下的一半链表，然后逐一判断每个节点的值是否相等：</p>
<pre><code class="language-c++">ListNode* reverseBetween(ListNode* s, ListNode* e) {
    ListNode *cur = s, *next = s;
    ListNode* prev = nullptr;
    while (cur != e) {
        next = cur-&gt;next;
        cur-&gt;next = prev;
        prev = cur;
        cur = next;
    }
    return prev;
}

bool isPalindrome(ListNode* head) {
    if (!head) {
        return false;
    }
    if (!head-&gt;next) {
        return true;
    }
    ListNode *slow = head, *fast = head;
    while (fast &amp;&amp; fast-&gt;next) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }
    ListNode *s = nullptr, *e = nullptr;
    if (fast) {
        s = slow-&gt;next;
    } else {
        s = slow;
    }
    ListNode* newHead = reverseBetween(s, e);
    while (head &amp;&amp; newHead) {
        if (head-&gt;val != newHead-&gt;val) {
            return false;
        } else {
            head = head-&gt;next;
            newHead = newHead-&gt;next;
        }
    }
    return true;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[图相关]]></title>
        <id>https://jsrdzhk.github.io/post/tu-xiang-guan/</id>
        <link href="https://jsrdzhk.github.io/post/tu-xiang-guan/">
        </link>
        <updated>2021-07-12T10:30:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-有向图的遍历">一、有向图的遍历</h2>
<p><a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/submissions/">797. 所有可能的路径 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>依然是使用递归进行遍历，使用一个变量记录当前路径的情况，在递归跳出的地方弹出当前节点的值（回溯）：</p>
<pre><code class="language-c++">void traverse(std::vector&lt;std::vector&lt;int&gt;&gt;&amp; graph, int idx, int target,
              std::vector&lt;std::vector&lt;int&gt;&gt;&amp; res, std::vector&lt;int&gt;&amp; seq) {
    if (idx == target) {
        seq.push_back(idx);
        res.push_back(seq);
        seq.pop_back();
    }
    auto&amp; g = graph[idx];
    for (auto num : g) {
        seq.push_back(idx);
        traverse(graph, num, target, res, seq);
        seq.pop_back();
    }
}

std::vector&lt;std::vector&lt;int&gt;&gt; allPathsSourceTarget(
    std::vector&lt;std::vector&lt;int&gt;&gt;&amp; graph) {
    std::vector&lt;int&gt; seq;
    std::vector&lt;std::vector&lt;int&gt;&gt; res;
    traverse(graph, 0, graph.size() - 1, res, seq);
    return res;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉搜索树（BST）]]></title>
        <id>https://jsrdzhk.github.io/post/er-cha-sou-suo-shu-bst/</id>
        <link href="https://jsrdzhk.github.io/post/er-cha-sou-suo-shu-bst/">
        </link>
        <updated>2021-07-12T10:29:17.000Z</updated>
        <content type="html"><![CDATA[<p>二叉搜索树基于二叉树，其左子树的所有节点均小于根结点，而右子树的所有节点均大于根结点，同时其左右子树又都是二叉搜索树。</p>
<h2 id="一-二叉搜索树中的第k个最小元素">一、二叉搜索树中的第K个最小元素</h2>
<p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>使用中序遍历就可以得到二叉搜索树中元素的升序排列：</p>
<pre><code class="language-c++">void traverse(TreeNode* n, int k, int&amp; c, int&amp; res) {
    if (!n) {
        return;
    }
    traverse(n-&gt;left, k, c, res);
    ++c;
    if (c == k) {
        res = n-&gt;val;
        return;
    } else if (c &gt; k) {
        return;
    } else {
        traverse(n-&gt;right, k, c, res);
    }
}

int kthSmallest(TreeNode* root, int k) {
    int res = 0, c = 0;
    traverse(root, k, c, res);
    return res;
}
</code></pre>
<p>当每次读取bst中的序列时，都自增计数器：</p>
<ul>
<li>当计数器等于要求的值时，保存结果；</li>
<li>当计数器小于要求的值时，继续读取；</li>
<li>当计数器大雨要求的值时，从递归中跳出。</li>
</ul>
<h2 id="二-把二叉搜索树转化为累加树">二、把二叉搜索树转化为累加树</h2>
<p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>根据题意，累加树就是使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和，简单来说就是将二叉搜索树中所有节点的值都增加该节点右子树所有节点之和。</p>
<p>中序遍历二叉搜索树最后才能访问到右子树，此时我们倒过来。先访问树的右子树，使用一个变量记录当前的右子树之和，然后将该变量加到树的根结点上，再访问左子树:</p>
<pre><code class="language-c++">void traverseBst(TreeNode* n, int&amp; sum) {
    if (!n) {
        return;
    }
    traverseBst(n-&gt;right, sum);
    n-&gt;val = n-&gt;val += sum;
    sum = n-&gt;val;
    traverseBst(n-&gt;left, sum);
}

TreeNode* bstToGst(TreeNode* root) {
    int sum = 0;
    traverseBst(root, sum);
    return root;
}
</code></pre>
<h2 id="三-不同的二叉搜索树">三、不同的二叉搜索树</h2>
<p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>当固定某个值<code>a</code>为根结点时，其左侧的值为<code>[1,a-1]</code>，右侧的值为<code>[a+1,n]</code>，定义<code>f(n)</code>为n个不同的数组成的二叉搜索树的种类，那么此时:</p>
<pre><code>f(n)=f(a-1-1+1)+f(n-(a+1)+1)
</code></pre>
<p>由此将求得<code>[1,n]</code>二叉搜索树的种类分解为了两个子问题，而当n=1或者0时，<code>f(n)</code>的结果显然为<code>1</code>，由此可以推断出：</p>
<pre><code>f(2)=f(1)*f(0)+f(0)*f(1)=2
f(3)=f(2)*f(0)+f(1)*f(1)+f(0)*f(2)=5
...
</code></pre>
<p>代码如下：</p>
<pre><code class="language-c++">int numTrees(int n) {
    std::vector&lt;int&gt; dp{1, 1};
    for (auto i = 2; i &lt;= n; ++i) {
        dp.push_back(0);
        for (auto j = 0; j &lt; i; ++j) {
            dp[i] += dp[j] * dp[i - 1 - j];
        }
    }
    return dp[n];
}
</code></pre>
<h2 id="四-不同的二叉搜索树二">四、不同的二叉搜索树（二）</h2>
<p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/submissions/">95. 不同的二叉搜索树 II - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<pre><code class="language-c++">std::vector&lt;TreeNode*&gt; constructBst(int s, int e) {
    std::vector&lt;TreeNode*&gt; res;
    if (s &gt; e) {
        res.push_back(nullptr);
        return res;
    }
    for (auto i = s; i &lt;= e; ++i) {
        auto leftRes = constructBst(s, i - 1);
        auto rightRes = constructBst(i + 1, e);
        for (auto l : leftRes) {
            for (auto r : rightRes) {
                TreeNode* node = new TreeNode(i);
                node-&gt;left = l;
                node-&gt;right = r;
                res.push_back(node);
            }
        }
    }
    return res;
}

std::vector&lt;TreeNode*&gt; generateTrees(int n) {
    return constructBst(1, n);
}
</code></pre>
<p>对于每一次递归，都会计算当前递归层次所有的左右子树可构建的二叉搜索树的根结点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git基础(一)]]></title>
        <id>https://jsrdzhk.github.io/post/git-ji-chu-yi/</id>
        <link href="https://jsrdzhk.github.io/post/git-ji-chu-yi/">
        </link>
        <updated>2021-07-11T02:12:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-基础概念">一、基础概念</h2>
<h3 id="11-什么是git">1.1 什么是git</h3>
<p><code>git</code>是版本管理系统（Version control systems ，VCS），用于对项目的版本进行跟踪管理。在git出现之前，拥有很多VCS，这些VCS的工作原理是对于项目中的每一个文件，保存他们随时间积累的改动。<br>
<img src="https://jsrdzhk.github.io/post-images/1625969667803.png" alt="normal vcs" loading="lazy"></p>
<p>git不同于其他版本管理工具，它每次改动都会保存所有项目文件的快照，如果某些文件在这次改动中没有变化，那么git只保存一个指向前一版本的链接。<br>
<img src="https://jsrdzhk.github.io/post-images/1625969745519.png" alt="git vcs" loading="lazy"></p>
<h3 id="12-git如何保证检查到所有改动">1.2 git如何保证检查到所有改动</h3>
<p>git会根据项目目录结构以及文件内容，通过<code>SHA-1</code>算法计算生成校验和，所以只要你对项目做了改动，git就能察觉。</p>
<h3 id="13-git的三种工作区域">1.3 git的三种工作区域</h3>
<p>git的工作区域分为工作区、暂存区和已提交区，当我们在项目中新增、修改文件时，这些改动都在工作区中。如果我们修改完成，使用<code>git add</code>命令，就可以讲这些改动由工作区移到暂存区。当文件处于暂存区时，我们就可以使用<code>git commit</code>命令将文件由暂存区挪到已提交区。当文件处于已提交区域时，所有的改动都会被永久保存在本地数据库中。如果你将项目根目录的<code>.git</code>文件夹删除，就会永久失去所有的版本记录。</p>
<figure data-type="image" tabindex="1"><img src="https://jsrdzhk.github.io/post-images/1625969769673.png" alt="git area" loading="lazy"></figure>
<h2 id="二-git基本使用方法">二、git基本使用方法</h2>
<h3 id="21-git初始配置">2.1 git初始配置</h3>
<p>当我们初次使用git，用到的最简单且必要的配置就是为git配置一个全局可用的提交者(还是作者？提交者和作者的区别？)的名字和其邮箱，其中<code>--global</code>参数表示本次配置对于本机所有的git仓库都有用，除非你在项目的局部配置文件里面进行了同样的配置，局部的配置会覆盖全局的配置。</p>
<pre><code class="language-shell">git config --global user.name &quot;zhanghaokang&quot;
git config --global user.email &quot;zhanghaokang@antiy.cn&quot;
</code></pre>
<p>此外，还需要配置git命令使用的编辑器，下面的命令就是将git默认的编辑器改为<code>vim</code>。</p>
<pre><code class="language-shell">git config --global core.editor vim
</code></pre>
<p>当使用<code>git commit</code>命令时，如果不使用<code>-m</code>参数加上提交信息，就会打开配置的editor让你进行下一步的操作。<br>
还有一个可选的配置：</p>
<pre><code class="language-shell">git config --global core.quotepath false
</code></pre>
<p>该配置会使<code>git status</code>的结果中的中文正常显示。</p>
<p>使用<code>git config --list</code>就可以展示出当前的所有配置。</p>
<h3 id="22-初始化仓库">2.2 初始化仓库</h3>
<p>在项目根目录使用<code>git init</code>就可以将项目生成为git项目，该操作会在项目根目录生成一个<code>.git</code>目录，他就用于记录版本的变化，并且我们可以在其中进行项目特有的配置，例如修改该仓库特有的提交者姓名和邮箱。</p>
<h3 id="23-将修改提交到本地仓库中">2.3 将修改提交到本地仓库中</h3>
<p>当项目被初始化为git仓库后，只要你在当前目录中新增文件时，git就会将该文件列为未被跟踪状态。使用<code>git status</code>可以看到当前仓库所有文件的状态。</p>
<pre><code class="language-shell">On branch master
Your branch is up to date with 'origin/master'.

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
	2.环境篇/工具部署和使用/开发工具/git/1.基础/
	2.环境篇/工具部署和使用/开发工具/git/git_reset_commit.md
	images/tools_deploy/dev/
</code></pre>
<p>可以看到，当前有一些文件和文件夹处于<code>Untracked files</code>中，这些文件处于未跟踪状态，对其进行修改git也不能知道改动的内容。此时，就需要使用<code>git add</code>命令，将文件添加到暂存区中。</p>
<pre><code class="language-shell">git add 2.环境篇/工具部署和使用/开发工具/git/1.基础/git_fundamental.md
</code></pre>
<p>在上面的命令结束后，再次运行<code>git status</code>来查看当前工作区的状态。</p>
<pre><code class="language-shell">On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)
	new file:   2.环境篇/工具部署和使用/开发工具/git/1.基础/git_fundamental.md

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
	2.环境篇/工具部署和使用/开发工具/git/git_reset_commit.md
	images/tools_deploy/dev/
</code></pre>
<p>可以看到，刚刚添加到暂存区的文件显示在<code>Changes to be committed</code>中，<code>git</code>还提示我们，如果我们想将该文件从暂存区移除，可以使用<code>git restore --staged &lt;file_name&gt;</code>命令。</p>
<p>当我们再次对该文件进行修改后，再次使用<code>git status</code>查看状态。</p>
<pre><code class="language-shell">On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)
	new file:   2.环境篇/工具部署和使用/开发工具/git/1.基础/git_fundamental.md

Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)
	modified:   2.环境篇/工具部署和使用/开发工具/git/1.基础/git_fundamental.md

Untracked files:
  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
	2.环境篇/工具部署和使用/开发工具/git/git_reset_commit.md
	images/tools_deploy/dev/
</code></pre>
<p>可以看到，现在又多出了一列<code>Changes not staged for commit</code>，这一列的文件中表示该文件已经被git所跟踪但是还有修改没用添加到暂存区。再次使用<code>git add</code>将修改添加到暂存区。</p>
<p>当所有的修改都添加到暂存区后，就可以使用<code>git commit</code>命令将这些修改挪到已提交区。</p>
<pre><code class="language-shell">git commit -m &quot;Develop | add git_fundamental.md&quot;
</code></pre>
<p>其中<code>-m</code>表示添加提交信息，如果不加该参数，git会打开你配置的默认编辑器，然后你在那里修改提交信息。</p>
<p>当该操作完成后，所有变动就会被添加到本地git仓库，你可以使用<code>git log</code>来查看所有提交记录。</p>
<pre><code>commit 552ec14f9ccdce80ae8c686820add3df7c800f9e (HEAD -&gt; master, origin/master, origin/HEAD)Author: zhaosq &lt;zhaosq0815@163.com&gt;Date:   Mon Nov 23 10:28:21 2020 +0800    Maintain | update test_tech on Nov 2020    Signed-off-by: zhaosq &lt;zhaosq0815@163.com&gt;commit f99fec9901064a78c7290e6bbd95de9660b17225Author: hangxu &lt;hangxu@antiy.cn&gt;Date:   Mon Nov 23 10:04:18 2020 +0800    Bug | fix style error
</code></pre>
<p>该命令会显示项目的所有提交历史，<code>commit</code>后面跟的是<code>commit id</code>，用于标记当前版本（SHA-1生成的校验和）。如果你后悔了，可以使用<code>git reset</code>命令将本地的内容返回到对应<code>commit id</code>的版本。</p>
<pre><code class="language-shell">git reset --hard f99fec9901064a78c7290e6bbd95de9660b17225
</code></pre>
<p>在<code>--hard</code>表示将所有内容返回到<code>f99fec9901064a78c7290e6bbd95de9660b17225</code>版本，如果使用<code>--soft</code>，那么<code>f99fec9901064a78c7290e6bbd95de9660b17225</code>版本到当前版本的所有改动将会保留在暂存区。</p>
<p>上述就是git的基本工作流程，下图也很好的概括了这些常用操作。</p>
<figure data-type="image" tabindex="2"><img src="https://jsrdzhk.github.io/post-images/1625969819544.png" alt="git work flow" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker镜像导入导出]]></title>
        <id>https://jsrdzhk.github.io/post/docker-image-import-and-export/</id>
        <link href="https://jsrdzhk.github.io/post/docker-image-import-and-export/">
        </link>
        <updated>2021-07-11T02:06:44.000Z</updated>
        <content type="html"><![CDATA[<p>在缺乏网络的环境中，可以将<code>Docker</code>镜像导出，进行离线部署。</p>
<h2 id="一-save-load">一、save &amp;&amp; load</h2>
<p><code>docker save</code>命令可以将多个镜像导出到文件中，用法如下:</p>
<pre><code class="language-sh">&gt;docker save --help

Usage:  docker save [OPTIONS] IMAGE [IMAGE...]

Save one or more images to a tar archive (streamed to STDOUT by default)

Options:
      --help            Print usage
  -o, --output string   Write to a file, instead of STDOUT
</code></pre>
<p>例如：</p>
<pre><code class="language-sh">docker save -o wq_ci.tar postgres:10 jenkins/jenkins:lts sonarqube:lts
</code></pre>
<p>在导出完成后，可以使用<code>docker load -i &lt;saved_image.tar&gt;</code>来加载导出的<code>image</code>。</p>
<h2 id="二-export-import">二、export &amp;&amp; import</h2>
<p><code>docker export</code>可以将<code>container</code>导出，用法如下:</p>
<pre><code class="language-sh">&gt;docker export --help

Usage:  docker export [OPTIONS] CONTAINER

Export a container's filesystem as a tar archive

Options:
      --help            Print usage
  -o, --output string   Write to a file, instead of STDOUT
</code></pre>
<p>例如：</p>
<pre><code class="language-sh">docker export -o postgres-export.tar postgres
</code></pre>
<p>使用<code>docker import</code>可以从导出文件生成<code>image</code>，例如：</p>
<pre><code class="language-sh">docker import postgres-export.tar postgres:latest
</code></pre>
<h2 id="三-save和export区别">三、save和export区别</h2>
<ol>
<li><code>docker save</code>保存的是<code>image</code>，<code>docker export</code>保存的是<code>container</code>；</li>
<li><code>docker load</code>用来载入<code>image</code>，<code>docker import</code>用来载入<code>container</code>包，但两者都会恢复为<code>image</code>；</li>
<li><code>docker load</code>不能对载入的<code>image</code>重命名，而docker import可以为<code>image</code>指定新名称。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Docker安装]]></title>
        <id>https://jsrdzhk.github.io/post/docker-installation/</id>
        <link href="https://jsrdzhk.github.io/post/docker-installation/">
        </link>
        <updated>2021-07-11T02:05:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-mac-os和windows">一、Mac OS和Windows</h2>
<p><code>Mac OS</code>可以直接去docker官方网站下载<code>Docker Desktop</code>，也可以使用<code>Homebrew</code>安装:<code>brew cask install docker</code>。<code>Windows</code>直接官方网站下载<code>Docker Desktop</code>即可。</p>
<h2 id="二-linux">二、Linux</h2>
<ol>
<li>
<p>更新ubuntu的apt源索引：sudo apt-get update</p>
</li>
<li>
<p>安装包允许apt通过HTTPS使用仓库：</p>
<pre><code class="language-shell">sudo apt-get install \
apt-transport-https \
ca-certificates \
curl \
software-properties-common
</code></pre>
</li>
<li>
<p>添加Docker官方GPG Key：</p>
<pre><code class="language-shell">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
</code></pre>
</li>
<li>
<p>设置Docker稳定版仓库：</p>
<pre><code class="language-shell">sudo add-apt-repository \
&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
$(lsb_release -cs) \
stable&quot;
</code></pre>
</li>
<li>
<p>添加仓库后，更新apt源索引：</p>
<pre><code class="language-shell">sudo apt-get update
</code></pre>
</li>
<li>
<p>安装最新版Docker CE(社区版)：</p>
<pre><code class="language-shell">sudo apt-get install docker-ce
</code></pre>
</li>
<li>
<p>检测Docker CE 是否安装正确：</p>
<pre><code class="language-shell">sudo docker run hellp-world
</code></pre>
</li>
</ol>
<h2 id="三-配置无需sudo运行">三、配置无需sudo运行</h2>
<p>在<code>Linux</code>中安装玩<code>Docker</code>后，需要进行以下配置：</p>
<ol>
<li>创建<code>Docker</code> group:<code>sudo groupadd docker</code>;</li>
<li>添加当前用户进入用户组:<code>sudo usermod -aG docker ${USER}</code>;</li>
<li>让修改生效:<code>su -s ${USER}</code>,或者直接登入登出。</li>
</ol>
<h2 id="四-配置国内镜像源">四、配置国内镜像源</h2>
<h3 id="41-mac-os">4.1 Mac OS</h3>
<p>对于使用 macOS 的用户，在任务栏点击 Docker Desktop 应用图标 -&gt; Perferences，在左侧导航菜单选择 Docker Engine，在右侧像下边一样编辑 json 文件。修改完成之后，点击 Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。</p>
<pre><code class="language-json">{
  &quot;registry-mirrors&quot;: [
    &quot;https://hub-mirror.c.163.com&quot;
  ]
}
</code></pre>
<h3 id="42-linux">4.2 Linux</h3>
<h4 id="421-systemdubuntu-1604-debian-8-centos-7">4.2.1 systemd(Ubuntu 16.04+、Debian 8+、CentOS 7)</h4>
<p>在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）:</p>
<pre><code class="language-json">{
  &quot;registry-mirrors&quot;: [
    &quot;https://hub-mirror.c.163.com&quot;
  ]
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树]]></title>
        <id>https://jsrdzhk.github.io/post/er-cha-shu/</id>
        <link href="https://jsrdzhk.github.io/post/er-cha-shu/">
        </link>
        <updated>2021-07-10T01:28:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-定义">一、定义</h2>
<pre><code class="language-c++">struct TreeNode {
     int val;
     TreeNode *left;
     TreeNode *right;
     TreeNode() : val(0), left(nullptr), right(nullptr) {}
     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
</code></pre>
<h2 id="二-二叉树的遍历">二、二叉树的遍历</h2>
<h3 id="21-前序遍历">2.1 前序遍历</h3>
<p>前序遍历（<strong>Pre-Order Traversal</strong>）的访问顺序为：</p>
<pre><code>根节点-&gt;左子树-&gt;右子树
</code></pre>
<h4 id="211-递归写法">2.1.1 递归写法</h4>
<pre><code class="language-c++">void recursivePreorderTraverseImpl(TreeNode *node, std::vector&lt;int&gt; &amp;res) {
    if (!node) {
        return;
    }
    res.push_back(node-&gt;val);
    recursivePreorderTraverseImpl(node-&gt;left, res);
    recursivePreorderTraverseImpl(node-&gt;right, res);
}

std::vector&lt;int&gt; recursivePreorderTraverse(TreeNode *root) {
    std::vector&lt;int&gt; res;
    recursivePreorderTraverseImpl(root, res);
    return res;
}
</code></pre>
<h4 id="212-迭代写法">2.1.2 迭代写法</h4>
<pre><code class="language-c++">std::vector&lt;int&gt; iterationPreorderTraverse(TreeNode *root) {
    std::vector&lt;int&gt; res;
    if (!root) {
        return res;
    }
    std::stack&lt;TreeNode *&gt; nodeStack;
    nodeStack.push(root);
    while (!nodeStack.empty()) {
        TreeNode *node = nodeStack.top();
        res.push_back(node-&gt;val);
        nodeStack.pop();
        if (node-&gt;right) {
            nodeStack.push(node-&gt;right);
        }
        if (node-&gt;left) {
            nodeStack.push(node-&gt;left);
        }
    }
    return res;
}
</code></pre>
<p>当使用迭代遍历二叉树时，使用以下步骤：</p>
<ol>
<li>首先将根节点<code>push</code>栈中</li>
<li>读取栈顶的值，并将右子节点和左子节点<code>push</code>到栈中，因为栈是先入后出，所以需要最后将左子节点<code>push</code>进去</li>
<li>重复1、2步读取栈顶节点</li>
</ol>
<h3 id="22-中序遍历">2.2 中序遍历</h3>
<p>中序遍历（<strong>In-Order Traversal</strong>）的访问顺序为：</p>
<pre><code>左子树-&gt;根节点-&gt;右子树
</code></pre>
<h4 id="221-递归写法">2.2.1 递归写法</h4>
<pre><code class="language-c++">void recursiveInorderTraverseImpl(TreeNode *node, std::vector&lt;int&gt; &amp;res) {
    if (!node) {
        return;
    }
    recursiveInorderTraverseImpl(node-&gt;left, res);
    res.push_back(node-&gt;val);
    recursiveInorderTraverseImpl(node-&gt;right, res);
}

std::vector&lt;int&gt; recursiveInorderTraverse(TreeNode *root) {
    std::vector&lt;int&gt; res;
    recursiveInorderTraverseImpl(root, res);
    return res;
}
</code></pre>
<h4 id="222-迭代写法">2.2.2 迭代写法</h4>
<pre><code class="language-c++">std::vector&lt;int&gt; iterationInorderTraverse(TreeNode *root) {
    std::vector&lt;int&gt; res;
    std::stack&lt;TreeNode *&gt; nodeStack;
    while (root || !nodeStack.empty()) {
        while (root) {
            nodeStack.push(root);
            root = root-&gt;left;
        }
        root = nodeStack.top();
        nodeStack.pop();
        res.push_back(root-&gt;val);
        root = root-&gt;right;
    }
    return res;
}
</code></pre>
<p>这里的思路就是模拟递归的遍历过程，关键在于使用<code>std::stack</code>来模拟函数调用栈：</p>
<ol>
<li>将根节点及其左子节点都<code>push</code>到栈中</li>
<li>当左右根节点及其左子节点都进入栈中后，将栈顶的节点弹出，由于该节点已经没有左子树，所以首先将它的值放到结果集中，然后将根节点设为该节点的右子节点</li>
<li>重复1、2步直至栈空。</li>
</ol>
<h3 id="23-后序遍历">2.3 后序遍历</h3>
<p>中序遍历（<strong>Post-Order Traversal</strong>）的访问顺序为：</p>
<pre><code>左子树-&gt;右子树-&gt;根节点
</code></pre>
<h4 id="231-递归写法">2.3.1 递归写法</h4>
<pre><code class="language-c++">void recursivePostorderTraverseImpl(TreeNode *node, std::vector&lt;int&gt; &amp;res) {
    if (!node) {
        return;
    }
    recursivePostorderTraverseImpl(node-&gt;left, res);
    recursivePostorderTraverseImpl(node-&gt;right, res);
    res.push_back(node-&gt;val);
}

std::vector&lt;int&gt; recursivePostorderTraverse(TreeNode *root) {
    std::vector&lt;int&gt; res;
    recursivePostorderTraverseImpl(root, res);
    return res;
}
</code></pre>
<h4 id="232-迭代写法">2.3.2 迭代写法</h4>
<pre><code class="language-c++">std::vector&lt;int&gt; iterationPostorderTraverse(TreeNode *root) {
    std::vector&lt;int&gt; res;
    if (!root) {
        return res;
    }
    std::stack&lt;TreeNode *&gt; nodeStack;
    nodeStack.push(root);
    while (!nodeStack.empty()) {
        TreeNode *node = nodeStack.top();
        nodeStack.pop();
        res.push_back(node-&gt;val);
        if (node-&gt;left) {
            nodeStack.push(node-&gt;left);
        }
        if (node-&gt;right) {
            nodeStack.push(node-&gt;right);
        }
    }
    std::reverse(res.begin(), res.end());
    return res;
}
</code></pre>
<p>类似于前序遍历的迭代写法，当我们调换push到栈中的左右子树顺序，那么结果就是：</p>
<pre><code>[根节点] [右子树] [左子树]
</code></pre>
<p>将结果倒序，就成为了：</p>
<pre><code>[左子树] [右子树] [根节点]
</code></pre>
<h3 id="24-层序遍历">2.4 层序遍历</h3>
<p>层序遍历按照树的层次依次遍历树的节点。</p>
<h4 id="241-利用队列">2.4.1 利用队列</h4>
<pre><code class="language-c++">std::vector&lt;int&gt; levelorderTraverse(TreeNode *root) {
    std::vector&lt;int&gt; res;
    if (!root) {
        return res;
    }
    std::queue&lt;TreeNode *&gt; q;
    q.push(root);
    while (!q.empty()) {
        TreeNode *node = q.front();
        res.push_back(node-&gt;val);
        if (node-&gt;left) {
            q.push(node-&gt;left);
        }
        if (node-&gt;right) {
            q.push(node-&gt;right);
        }
        q.pop();
    }
    return res;
}
</code></pre>
<p>这里借助队列完成层序遍历：</p>
<ol>
<li>将根节点<code>push</code>到队列中</li>
<li>读取队列头部的节点内容，然后将该节点的左子节点和右子节点<code>push</code>到队列中</li>
<li>将队列头部节点弹出队列</li>
<li>重复2、3步直至队列为空</li>
</ol>
<h4 id="242-将结果按层输出">2.4.2 将结果按层输出</h4>
<p>上一节将所有结果都放到一个动态数组中，如果需要将结果分层放入到不同的动态数组中，则需要稍微改动一点代码。实际上，刚刚每次读取头部节点并将左子节点和右子节点<code>push</code>到队列中的操作，就是将下一层的节点放到队列末尾，等待该层所有节点遍历完毕，才回去遍历下一层的节点。</p>
<p>所以，这里使用一个辅助的队列，用于存放下一层的所有节点。当该层节点都遍历完成后，在遍历辅助队列中的下一层节点。</p>
<pre><code class="language-c++">std::vector&lt;std::vector&lt;int&gt;&gt; levelorderTraverse2(TreeNode *root) {
    std::vector&lt;std::vector&lt;int&gt;&gt; res;
    if (!root) {
        return res;
    }
    std::queue&lt;TreeNode *&gt; q;
    q.push(root);
    while (!q.empty()) {
        std::queue&lt;TreeNode *&gt; tmp;
        std::vector&lt;int&gt; line;
        while (!q.empty()) {
            TreeNode *node = q.front();
            q.pop();
            line.push_back(node-&gt;val);
            if (node-&gt;left) {
                tmp.push(node-&gt;left);
            }
            if (node-&gt;right) {
                tmp.push(node-&gt;right);
            }
        }
        res.push_back(line);
        q = tmp;
    }
    return res;
}
</code></pre>
<p>其实，不借助辅助队列也是可以的，因为每次<code>push</code>都会将所有下一层的子节点都放到队列中，只需要在遍历这些节点前记录下一层子节点的数量即可：</p>
<pre><code class="language-c++">std::vector&lt;std::vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
    std::vector&lt;std::vector&lt;int&gt;&gt; res;
    std::queue&lt;TreeNode*&gt; q;
    q.push(root);
    while (!q.empty()) {
        auto len = q.size();
        std::vector&lt;int&gt; line;
        for (auto i = 0; i &lt; len; ++i) {
            TreeNode* n = q.front();
            q.pop();
            if (!n) {
                continue;
            }
            line.push_back(n-&gt;val);
            if (n-&gt;left) {
                q.push(n-&gt;left);
            }
            if (n-&gt;right) {
                q.push(n-&gt;right);
            }
        }
        if (!line.empty()) {
            res.push_back(line);
        }
    }
    return res;
}
</code></pre>
<h2 id="三-n叉树的遍历">三、n叉树的遍历</h2>
<p>n叉树的定义类似于二叉树，n叉树拥有不定数量的子节点，它的遍历相较于二叉树，没有本质区别，下面仅给出代码。</p>
<pre><code class="language-c++">class Node {
   public:
    int val;
    std::vector&lt;Node *&gt; children;
    Node() {}
    Node(int _val) { val = _val; }
    Node(int _val, std::vector&lt;Node *&gt; _children) {
        val = _val;
        children = _children;
    }
};
</code></pre>
<h3 id="31-前序遍历">3.1 前序遍历</h3>
<p><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">589. N 叉树的前序遍历 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h4 id="311-递归写法">3.1.1 递归写法</h4>
<pre><code class="language-c++">void recursiveNArrPreorderTraverseImpl(Node *node, std::vector&lt;int&gt; &amp;res) {
    if (!node) {
        return;
    }
    res.push_back(node-&gt;val);
    for (auto c : node-&gt;children) {
        recursiveNArrPreorderTraverseImpl(c, res);
    }
}

std::vector&lt;int&gt; recursiveNArrPreorderTraverse(Node *root) {
    std::vector&lt;int&gt; res;
    recursiveNArrPreorderTraverseImpl(root, res);
    return res;
}
</code></pre>
<h4 id="312-迭代写法">3.1.2 迭代写法</h4>
<pre><code class="language-c++">std::vector&lt;int&gt; iterationNArrPreorderTraverse(Node *root) {
    std::vector&lt;int&gt; res;
    if (!root) {
        return res;
    }
    std::stack&lt;Node *&gt; s;
    s.push(root);
    while (!s.empty()) {
        Node *node = s.top();
        s.pop();
        res.push_back(node-&gt;val);
        auto &amp;c = node-&gt;children;
        for (auto rb = c.rbegin(); rb != c.rend(); ++rb) {
            if (*rb) {
                s.push(*rb);
            }
        }
    }
    return res;
}
</code></pre>
<h3 id="32-后序遍历">3.2 后序遍历</h3>
<p><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">590. N 叉树的后序遍历 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h4 id="321-递归写法">3.2.1 递归写法</h4>
<pre><code class="language-c++">void recursiveNArrPostorderTraverseImpl(Node *node, std::vector&lt;int&gt; &amp;res) {
    if (!node) {
        return;
    }
    for (auto c : node-&gt;children) {
        recursiveNArrPostorderTraverseImpl(c, res);
    }
    res.push_back(node-&gt;val);
}

std::vector&lt;int&gt; recursiveNArrPostorderTraverse(Node *root) {
    std::vector&lt;int&gt; res;
    recursiveNArrPostorderTraverseImpl(root, res);
    return res;
}
</code></pre>
<h4 id="322-迭代写法">3.2.2 迭代写法</h4>
<pre><code class="language-c++">std::vector&lt;int&gt; iterationNArrPostorderTraverse(Node *root) {
    std::vector&lt;int&gt; res;
    if (!root) {
        return res;
    }
    std::stack&lt;Node *&gt; s;
    s.push(root);
    while (!s.empty()) {
        Node *node = s.top();
        s.pop();
        res.push_back(node-&gt;val);
        auto &amp;c = node-&gt;children;
        for (auto pc : c) {
            s.push(pc);
        }
    }
    std::reverse(res.begin(), res.end());
    return res;
}
</code></pre>
<h3 id="33-层序遍历">3.3 层序遍历</h3>
<p><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">429. N 叉树的层序遍历 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<pre><code class="language-c++">std::vector&lt;std::vector&lt;int&gt;&gt; nArrLevelorderTraverse(Node *root) {
    std::vector&lt;std::vector&lt;int&gt;&gt; res;
    if (!root) {
        return res;
    }
    std::queue&lt;Node *&gt; q;
    q.push(root);
    while (!q.empty()) {
        std::vector&lt;int&gt; line;
        std::queue&lt;Node *&gt; tmp;
        while (!q.empty()) {
            Node *n = q.front();
            q.pop();
            line.push_back(n-&gt;val);
            auto &amp;c = n-&gt;children;
            for (auto pc : c) {
                if (pc) {
                    tmp.push(pc);
                }
            }
        }
        res.push_back(line);
        q = tmp;
    }
    return res;
}
</code></pre>
<h2 id="四-二叉树的反转">四、二叉树的反转</h2>
<p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h3 id="41-递归写法">4.1 递归写法</h3>
<pre><code class="language-c++">void invertTreeImpl(TreeNode* node) {
    if (!node) {
        return;
    }
    std::swap(node-&gt;left, node-&gt;right);
    invertTreeImpl(node-&gt;left);
    invertTreeImpl(node-&gt;right);
}

TreeNode* invertTree(TreeNode* root) {
    if (!root) {
        return nullptr;
    }
    invertTreeImpl(root);
    return root;
}
</code></pre>
<h3 id="42-迭代写法">4.2 迭代写法</h3>
<pre><code class="language-c++">TreeNode* iterationInvertTree(TreeNode* root) {
    std::queue&lt;TreeNode*&gt; q;
    q.push(root);
    while (!q.empty()) {
        TreeNode* n = q.front();
        q.pop();
        if (!n) {
            continue;
        }
        std::swap(n-&gt;left, n-&gt;right);
        q.push(n-&gt;left);
        q.push(n-&gt;right);
    }
    return root;
}
</code></pre>
<h3 id="43-think">4.3 think</h3>
<p>反转二叉树的主要步骤就是<code>std::swap(n-&gt;left, n-&gt;right)</code>，所以只要对于所有节点都执行一次<code>swap</code>操作就可以了，所以本质上，二叉树的反转依旧是二叉树的遍历问题。对于递归写法，你可以将<code>swap</code>操作放在递归调用点的任何地方，<strong>但是注意，当你放在中间使用中序遍历的时候，需要做一些小的修改，因为<code>std::swap</code>修改了<code>TreeNode*</code>指针的指向，所以你需要将第二个<code>node-&gt;right</code>修改为<code>node-&gt;left</code></strong>：</p>
<pre><code class="language-c++">void invertTreeInorderImpl(TreeNode* node) {
    if (!node) {
        return;
    }
    invertTreeInorderImpl(node-&gt;left);
    std::swap(node-&gt;left, node-&gt;right);
    invertTreeInorderImpl(node-&gt;left);
}
</code></pre>
<p>对于迭代写法，也是同样的道理。</p>
<h2 id="五-填充每个节点的下一个右侧节点指针">五、填充每个节点的下一个右侧节点指针</h2>
<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h3 id="51-层序遍历">5.1 层序遍历</h3>
<p>由于二叉树为完美二叉树，所有父节点都有两个子节点，所以首先会想到使用层序遍历，将每层的节点都存储到队列中，然后处理队列中的节点，代码只需要在[2.4.2](#2.4.2  将结果按层输出)的基础上稍作修改：</p>
<pre><code class="language-c++">Node* connect(Node* root) {
    std::queue&lt;Node*&gt; q;
    q.push(root);
    while (!q.empty()) {
        auto len = q.size();
        for (auto i = 0; i &lt; len; ++i) {
            Node* n = q.front();
            q.pop();
            if (!n) {
                continue;
            }
            if (i &lt; len - 1) {
                n-&gt;next = q.front();
            }
            q.push(n-&gt;left);
            q.push(n-&gt;right);
        }
    }
    return root;
}
</code></pre>
<h3 id="52-递归写法">5.2 递归写法</h3>
<p>根据要求，需要讲所有层级的子节点都指向右侧节点，所以不但需要将左右两个子节点连接，还需要将前一个节点的右子节点和后一个节点的左子节点连接。显然，使用一个节点无法完成跨节点的连接，所以需要两个节点：</p>
<pre><code class="language-c++">void recursiveConnectImpl(Node* n1, Node* n2) {
    if (!n1 || !n2) {
        return;
    }
    n1-&gt;next = n2;
    recursiveConnectImpl(n1-&gt;left, n1-&gt;right);
    recursiveConnectImpl(n1-&gt;right, n2-&gt;left);
    recursiveConnectImpl(n2-&gt;left, n2-&gt;right);
}

Node* recursiveConnect(Node* root) {
    if (root) {
        recursiveConnectImpl(root-&gt;left, root-&gt;right);
    }
    return root;
}
</code></pre>
<h2 id="六-二叉树转化为链表">六、二叉树转化为链表</h2>
<p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<h3 id="61-前序遍历后修改">6.1 前序遍历后修改</h3>
<p>很自然地，使用前序遍历的方式将所有节点都存放在动态数组中，再依次修改节点的指向，形成单向链表：</p>
<pre><code class="language-c++">void traverseTree(TreeNode* node, std::vector&lt;TreeNode*&gt;&amp; res) {
    if (!node) {
        return;
    }
    res.push_back(node);
    traverseTree(node-&gt;left, res);
    traverseTree(node-&gt;right, res);
}

void flatten(TreeNode* root) {
    std::vector&lt;TreeNode*&gt; res;
    traverseTree(root, res);
    if (res.empty()) {
        return;
    }
    int len = res.size();
    for (auto i = 0; i &lt; len - 1; ++i) {
        res[i]-&gt;right = res[i + 1];
        res[i]-&gt;left = nullptr;
    }
}
</code></pre>
<p>这里注意，在<code>C++</code>中，当<code>unsigned</code>与<code>signed</code>相减时，结果会被转化为<code>unsigned</code>，所以当<code>root</code>节点为<code>nullptr</code>时，存放节点的<code>vector</code>就是空的，此时<code>res.size()-1</code>的结果会由<code>-1</code>转化为<code>unsigned</code>，具体结果根据机器架构的不同而有差异。在32位机器上，一般来说<code>signed</code>会使用最高位表示符号位，此时<code>-1</code>的二进制表示就是<code>1000 0000 0000 0000 0000 0000 0000 0001</code>，转化为<code>unsigned</code>就是<code>2^31+2^0</code>，即<code>2147483649</code>，所以在<code>for</code>循环中涉及到<code>vector</code>的<code>size()</code>运算时，最好先讲<code>size()</code>转化为<code>signed</code>整数。</p>
<h3 id="62-递归写法">6.2 递归写法</h3>
<p>递归写法在于先将树展开，然后将左子树接到右子树上，再将原来的右子树接到左子树下方:</p>
<pre><code class="language-c++">void flatten2(TreeNode* root) {
    if (!root) {
        return;
    }
    flatten2(root-&gt;left);
    flatten2(root-&gt;right);
    TreeNode* right = root-&gt;right;
    TreeNode* left = root-&gt;left;
    root-&gt;left = nullptr;
    root-&gt;right = left;
    TreeNode* p = root;
    while (p-&gt;right) {
        p = p-&gt;right;
    }
    p-&gt;right = right;
}
</code></pre>
<h2 id="七-构建二叉树">七、构建二叉树</h2>
<h3 id="71-最大二叉树">7.1 最大二叉树</h3>
<p><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">654. 最大二叉树 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>首先要明确每次递归要做的事情，在这里，我们需要：</p>
<ol>
<li>求得数组的最大值</li>
<li>将最大值构建为一个树节点并连接到父节点上</li>
<li>分别对最大值左右两侧的子数组进行递归调用</li>
</ol>
<p><code>getMax</code>函数用于求得子数组的最大值及其所处的位置，这里我们选取的递归<code>base case</code>为当最大值的左右两侧是否还具有子数组：</p>
<pre><code class="language-c++">std::pair&lt;int, int&gt; getMax(const std::vector&lt;int&gt;&amp; nums, int s, int e) {
    int max = 0, maxPos = 0;
    for (auto i = s; i &lt;= e; ++i) {
        if (nums[i] &gt;= max) {
            max = nums[i];
            maxPos = i;
        }
    }
    return std::make_pair(max, maxPos);
}

TreeNode* constructImpl(const std::vector&lt;int&gt;&amp; nums, int s, int e) {
    auto maxPair = getMax(nums, s, e);
    auto maxNum = maxPair.first;
    auto maxPos = maxPair.second;
    TreeNode* newNode = new TreeNode(maxNum);
    if (maxPos &gt; s) {
        newNode-&gt;left = constructImpl(nums, s, maxPos - 1);
    }
    if (maxPos &lt; e) {
        newNode-&gt;right = constructImpl(nums, maxPos + 1, e);
    }
    return newNode;
}

TreeNode* constructMaximumBinaryTree(std::vector&lt;int&gt;&amp; nums) {
    if (nums.empty()) {
        return nullptr;
    }
    return constructImpl(nums, 0, nums.size() - 1);
}
</code></pre>
<h3 id="72-从前序遍历和中序遍历结果构建二叉树">7.2 从前序遍历和中序遍历结果构建二叉树</h3>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>由于前序遍历的结果为：</p>
<pre><code>[根结点] [左子树] [右子树]
</code></pre>
<p>而中序遍历的结果为：</p>
<pre><code>[左子树] [根结点] [右子树]
</code></pre>
<p>同时序列中没有重复数字，所以可以根据前序遍历结果得到根结点的值，再到中序遍历的结果中找到该值所在的位置，就可以构建该节点及其左右子树，显然这是一个递归的构建过程：</p>
<pre><code class="language-c++">std::size_t getInorderRootPos(int rootNodeVal, const std::vector&lt;int&gt;&amp; inorder,
                              std::size_t inorderStart,
                              std::size_t inorderEnd) {
    for (auto i = inorderStart; i &lt;= inorderEnd; ++i) {
        if (inorder[i] == rootNodeVal) {
            return i;
        }
    }
    return 0;
}

TreeNode* constructBinaryTree(const std::vector&lt;int&gt;&amp; preorder,
                              const std::vector&lt;int&gt;&amp; inorder,
                              std::size_t preorderStart,
                              std::size_t preorderEnd, std::size_t inorderStart,
                              std::size_t inorderEnd) {
    auto rootNodeVal = preorder[preorderStart];
    TreeNode* n = new TreeNode(rootNodeVal);
    auto inorderRootPos =
        getInorderRootPos(rootNodeVal, inorder, inorderStart, inorderEnd);
    auto leftSubTreeLen = inorderRootPos - inorderStart;
    if (leftSubTreeLen &gt; 0) {
        n-&gt;left = constructBinaryTree(preorder, inorder, preorderStart + 1,
                                      preorderStart + leftSubTreeLen,
                                      inorderStart, inorderRootPos - 1);
    }
    auto rightSubTreeLen = inorderEnd - inorderRootPos;
    if (rightSubTreeLen &gt; 0) {
        n-&gt;right = constructBinaryTree(
            preorder, inorder, preorderStart + leftSubTreeLen + 1, preorderEnd,
            inorderRootPos + 1, inorderEnd);
    }
    return n;
}

TreeNode* buildTree(std::vector&lt;int&gt;&amp; preorder, std::vector&lt;int&gt;&amp; inorder) {
    if (preorder.empty()) {
        return nullptr;
    }
    return constructBinaryTree(preorder, inorder, 0, preorder.size() - 1, 0,
                               inorder.size() - 1);
}
</code></pre>
<h3 id="73-从中序与后序遍历序列构造二叉树">7.3 从中序与后序遍历序列构造二叉树</h3>
<p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>由于后序遍历的结果为：</p>
<pre><code>[左子树] [右子树] [根结点]
</code></pre>
<p>所以可以找到跟节点的值。</p>
<p>又因为序列没有重复数字，而中序遍历的结果为：</p>
<pre><code>[左子树] [根结点] [右子树]
</code></pre>
<p>所以可以得到改根结点的左右子树，代码类似<code>7.2</code>：</p>
<pre><code class="language-c++">std::size_t getInorderRootPos(int rootNodeVal, const std::vector&lt;int&gt;&amp; inorder,
                              std::size_t inorderStart,
                              std::size_t inorderEnd) {
    for (auto i = inorderStart; i &lt;= inorderEnd; ++i) {
        if (inorder[i] == rootNodeVal) {
            return i;
        }
    }
    return 0;
}

TreeNode* constructBinaryTree(const std::vector&lt;int&gt;&amp; postorer,
                              const std::vector&lt;int&gt;&amp; inorder,
                              std::size_t postorerStart,
                              std::size_t postorerEnd, std::size_t inorderStart,
                              std::size_t inorderEnd) {
    auto rootNodeVal = postorer[postorerEnd];
    TreeNode* n = new TreeNode(rootNodeVal);
    auto inorderRootPos =
        getInorderRootPos(rootNodeVal, inorder, inorderStart, inorderEnd);
    auto leftSubTreeLen = inorderRootPos - inorderStart;
    if (leftSubTreeLen &gt; 0) {
        n-&gt;left = constructBinaryTree(postorer, inorder, postorerStart,
                                      postorerStart + leftSubTreeLen - 1,
                                      inorderStart, inorderRootPos - 1);
    }
    auto rightSubTreeLen = inorderEnd - inorderRootPos;
    if (rightSubTreeLen &gt; 0) {
        n-&gt;right = constructBinaryTree(
            postorer, inorder, postorerStart + leftSubTreeLen, postorerEnd - 1,
            inorderRootPos + 1, inorderEnd);
    }
    return n;
}

TreeNode* buildTree(std::vector&lt;int&gt;&amp; inorder, std::vector&lt;int&gt;&amp; postorder) {
    if (postorder.empty()) {
        return nullptr;
    }
    return constructBinaryTree(postorder, inorder, 0, postorder.size() - 1, 0,
                               inorder.size() - 1);
}
</code></pre>
<h2 id="八-寻找重复子树">八、寻找重复子树</h2>
<p><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">652. 寻找重复的子树 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p>使用前序遍历，将所有子树的前序遍历结果保存在哈希表中，当前序遍历结果等于2时，说明此子树重复。</p>
<pre><code class="language-c++">std::string getSubTreeSeq(TreeNode* n,
                          std::unordered_map&lt;std::string, int&gt;&amp; counter,
                          std::vector&lt;TreeNode*&gt;&amp; res) {
    if (!n) {
        return &quot;$&quot;;
    }
    std::ostringstream oss;
    oss &lt;&lt; n-&gt;val &lt;&lt; ',' &lt;&lt; getSubTreeSeq(n-&gt;left, counter, res) &lt;&lt; ','
        &lt;&lt; getSubTreeSeq(n-&gt;right, counter, res);
    std::string seq = oss.str();
    ++counter[seq];
    if (counter[seq] == 2) {
        res.push_back(n);
    }
    return seq;
}

std::vector&lt;TreeNode*&gt; findDuplicateSubtrees2(TreeNode* root) {
    std::unordered_map&lt;std::string, int&gt; counter;
    std::vector&lt;TreeNode*&gt; res;
    getSubTreeSeq(root, counter, res);
    return res;
}
</code></pre>
]]></content>
    </entry>
</feed>